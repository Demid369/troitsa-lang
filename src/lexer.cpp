/**
 * @file: lexer.cpp
 * @description: Реализация лексического анализатора языка "Троица"
 * @dependencies: lexer.hpp
 * @created: 2026-02-02
 */

#include "troitsa/lexer.hpp"
#include <cctype>
#include <stdexcept>

namespace Троица {

// Таблица ключевых слов
const std::unordered_map<std::string, ТипТокена> Лексер::КЛЮЧЕВЫЕ_СЛОВА = {
    // Управляющие конструкции
    {"функция", ТипТокена::КлючФункция},
    {"тип", ТипТокена::КлючТип},
    {"пусть", ТипТокена::КлючПусть},
    {"изм", ТипТокена::КлючИзменяемый},
    {"вернуть", ТипТокена::КлючВернуть},
    {"если", ТипТокена::КлючЕсли},
    {"иначе", ТипТокена::КлючИначе},
    {"выбор", ТипТокена::КлючВыбор},
    {"сопоставить", ТипТокена::КлючСопоставить},
    {"цикл", ТипТокена::КлючЦикл},
    {"пока", ТипТокена::КлючПока},
    {"для", ТипТокена::КлючДля},
    {"в", ТипТокена::КлючВ},
    {"прервать", ТипТокена::КлючПрервать},
    {"продолжить", ТипТокена::КлючПродолжить},
    
    // Эффекты и задачи
    {"эффект", ТипТокена::КлючЭффект},
    {"с", ТипТокена::КлючС},
    {"обработать", ТипТокена::КлючОбработать},
    {"задача", ТипТокена::КлючЗадача},
    {"под", ТипТокена::КлючПод},
    
    // Метапрограммирование
    {"макрос", ТипТокена::КлючМакрос},
    {"цитата", ТипТокена::КлючЦитата},
    
    // Владение
    {"владеть", ТипТокена::КлючВладеть},
    {"линейный", ТипТокена::КлючЛинейный},
    
    // Классы и модули
    {"класс", ТипТокена::КлючКласс},
    {"новый", ТипТокена::КлючНовый},
    {"этот", ТипТокена::КлючЭтот},
    {"родитель", ТипТокена::КлючРодитель},
    {"наследует", ТипТокена::КлючНаследует},
    {"импорт", ТипТокена::КлючИмпорт},
    {"экспорт", ТипТокена::КлючЭкспорт},
    {"из", ТипТокена::КлючИз},
    {"как", ТипТокена::КлючКак},
    {"статический", ТипТокена::КлючСтатический},
    {"частный", ТипТокена::КлючЧастный},
    {"общий", ТипТокена::КлючОбщий},
    
    // Троичные значения
    {"Да", ТипТокена::КлючДа},
    {"Нет", ТипТокена::КлючНет},
    {"Может", ТипТокена::КлючМожет},
    {"Есть", ТипТокена::КлючЕсть},
    {"Неизвестно", ТипТокена::КлючНеизвестно},
    
    // Типы
    {"Трит", ТипТокена::КлючТрит},
    {"Трайт", ТипТокена::КлючТрайт},
    {"Гармония", ТипТокена::КлючГармония},
    {"Строка", ТипТокена::КлючСтрока},
    {"Логика", ТипТокена::КлючЛогика},
    {"Возможно", ТипТокена::КлючВозможно},
    {"Список", ТипТокена::КлючСписок},
    {"Словарь", ТипТокена::КлючСловарь},
    {"Результат", ТипТокена::КлючРезультат},
    
    // Логические операторы (русские)
    {"И", ТипТокена::ОпИ},
    {"и", ТипТокена::ОпИ},
    {"ИЛИ", ТипТокена::ОпИли},
    {"или", ТипТокена::ОпИли},
    {"НЕ", ТипТокена::ОпНе},
    {"не", ТипТокена::ОпНе},
    {"КОНСЕНСУС", ТипТокена::ОпКонсенсус},
};

// === Конструктор ===

Лексер::Лексер(std::string_view исходник, std::string имяФайла)
    : исходник_(исходник)
    , имяФайла_(std::move(имяФайла))
    , текущий_(0)
    , позиция_(1, 1, 0)
{
}

// === Основные методы ===

Токен Лексер::следующийТокен() {
    // Если есть буферизованный токен, вернуть его
    if (буфер_) {
        Токен т = std::move(*буфер_);
        буфер_.reset();
        return т;
    }
    
    пропуститьПробелы();
    
    if (конец()) {
        return Токен(ТипТокена::КонецФайла, позиция_);
    }
    
    char32_t с = текущийСимвол();
    
    // Идентификатор или ключевое слово
    if (началоИдентификатора(с)) {
        return сканироватьИдентификатор();
    }
    
    // Число
    if (цифра(с)) {
        // Проверяем троичный литерал: 0т...
        if (с == U'0' && следующийСимвол() == U'\u0442') { // 'т'
            return сканироватьТроичное();
        }
        return сканироватьЧисло();
    }
    
    // Строка
    if (с == U'"') {
        return сканироватьСтроку();
    }
    
    // Символ
    if (с == U'\'') {
        return сканироватьСимвол();
    }
    
    // Оператор или разделитель
    return сканироватьОператор();
}

Токен Лексер::заглянуть() {
    if (!буфер_) {
        буфер_ = следующийТокен();
    }
    return *буфер_;
}

std::vector<Токен> Лексер::токенизировать() {
    std::vector<Токен> токены;
    
    while (true) {
        Токен т = следующийТокен();
        токены.push_back(т);
        
        if (т.конецФайла()) {
            break;
        }
    }
    
    return токены;
}

bool Лексер::конец() const noexcept {
    return текущий_ >= исходник_.size();
}

// === Вспомогательные методы ===

char32_t Лексер::текущийСимвол() const {
    if (конец()) return U'\0';
    
    size_t длина = 0;
    return декодироватьUTF8(исходник_.data() + текущий_, длина);
}

char32_t Лексер::следующийСимвол() const {
    if (конец()) return U'\0';
    
    size_t длина = длинаUTF8(исходник_[текущий_]);
    if (текущий_ + длина >= исходник_.size()) return U'\0';
    
    size_t дл = 0;
    return декодироватьUTF8(исходник_.data() + текущий_ + длина, дл);
}

void Лексер::продвинуться() {
    if (конец()) return;
    
    char32_t с = текущийСимвол();
    size_t длина = длинаUTF8(исходник_[текущий_]);
    
    текущий_ += длина;
    позиция_.смещение = текущий_;
    
    if (с == U'\n') {
        позиция_.строка++;
        позиция_.столбец = 1;
    } else {
        позиция_.столбец++;
    }
}

void Лексер::пропуститьПробелы() {
    while (!конец()) {
        char32_t с = текущийСимвол();
        
        if (пробел(с)) {
            продвинуться();
        } else if (с == U'/') {
            char32_t след = следующийСимвол();
            if (след == U'/') {
                пропуститьОднострочныйКомментарий();
            } else if (след == U'*') {
                пропуститьМногострочныйКомментарий();
            } else {
                break;
            }
        } else {
            break;
        }
    }
}

void Лексер::пропуститьОднострочныйКомментарий() {
    // Пропускаем //
    продвинуться();
    продвинуться();
    
    while (!конец() && текущийСимвол() != U'\n') {
        продвинуться();
    }
}

void Лексер::пропуститьМногострочныйКомментарий() {
    // Пропускаем /*
    продвинуться();
    продвинуться();
    
    while (!конец()) {
        if (текущийСимвол() == U'*' && следующийСимвол() == U'/') {
            продвинуться();
            продвинуться();
            return;
        }
        продвинуться();
    }
    
    добавитьОшибку("Незакрытый многострочный комментарий");
}

// === Сканирование токенов ===

Токен Лексер::сканироватьИдентификатор() {
    Позиция начало = позиция_;
    std::string текст;
    
    while (!конец() && продолжениеИдентификатора(текущийСимвол())) {
        size_t длина = длинаUTF8(исходник_[текущий_]);
        текст.append(исходник_.data() + текущий_, длина);
        продвинуться();
    }
    
    // Проверяем, ключевое ли это слово
    auto it = КЛЮЧЕВЫЕ_СЛОВА.find(текст);
    if (it != КЛЮЧЕВЫЕ_СЛОВА.end()) {
        return Токен(it->second, начало, текст);
    }
    
    return Токен(ТипТокена::Идентификатор, текст, начало, текст);
}

Токен Лексер::сканироватьЧисло() {
    Позиция начало = позиция_;
    std::string текст;
    bool отрицательное = false;
    bool вещественное = false;
    
    // Знак
    if (текущийСимвол() == U'-') {
        отрицательное = true;
        текст += '-';
        продвинуться();
    } else if (текущийСимвол() == U'+') {
        текст += '+';
        продвинуться();
    }
    
    // Целая часть
    while (!конец() && цифра(текущийСимвол())) {
        текст += static_cast<char>(текущийСимвол());
        продвинуться();
    }
    
    // Дробная часть (если есть точка и за ней цифра)
    if (!конец() && текущийСимвол() == U'.') {
        // Проверяем, что после точки идёт цифра
        size_t следующаяПозиция = позиция_.смещение + 1;
        if (следующаяПозиция < исходник_.size() && 
            цифра(static_cast<char32_t>(исходник_[следующаяПозиция]))) {
            вещественное = true;
            текст += '.';
            продвинуться();
            
            while (!конец() && цифра(текущийСимвол())) {
                текст += static_cast<char>(текущийСимвол());
                продвинуться();
            }
        }
    }
    
    // Преобразуем в число
    try {
        if (вещественное) {
            double значение = std::stod(текст);
            return Токен(ТипТокена::ЧислоВещественное, значение, начало, текст);
        } else {
            int64_t значение = std::stoll(текст);
            return Токен(ТипТокена::ЧислоЦелое, значение, начало, текст);
        }
    } catch (...) {
        return токенОшибки("Некорректное число: " + текст);
    }
}

Токен Лексер::сканироватьТроичное() {
    Позиция начало = позиция_;
    std::string текст;
    
    // Пропускаем 0т
    текст += '0';
    продвинуться();
    
    // Проверяем 'т' (кириллическая)
    size_t длина = длинаUTF8(исходник_[текущий_]);
    текст.append(исходник_.data() + текущий_, длина);
    продвинуться();
    
    // Читаем троичные цифры: +, -, 0, 1, T (или кириллические эквиваленты)
    int64_t значение = 0;
    int позицияТрита = 0;
    std::string цифры;
    
    while (!конец()) {
        char32_t с = текущийСимвол();
        int трит = 0;
        
        if (с == U'+' || с == U'1' || с == U'\u002B') {
            трит = 1;
        } else if (с == U'-' || с == U'T' || с == U'\u2212' || с == U'\u0422') { // T или Т
            трит = -1;
        } else if (с == U'0') {
            трит = 0;
        } else {
            break;
        }
        
        цифры += static_cast<char>(с);
        продвинуться();
        позицияТрита++;
    }
    
    // Вычисляем значение (от старшего к младшему)
    int степень = 1;
    for (int i = static_cast<int>(цифры.size()) - 1; i >= 0; --i) {
        char ц = цифры[i];
        int трит = 0;
        if (ц == '+' || ц == '1') трит = 1;
        else if (ц == '-' || ц == 'T') трит = -1;
        
        значение += трит * степень;
        степень *= 3;
    }
    
    текст += цифры;
    return Токен(ТипТокена::ЧислоТроичное, значение, начало, текст);
}

Токен Лексер::сканироватьСтроку() {
    Позиция начало = позиция_;
    std::string текст;
    std::string значение;
    
    текст += '"';
    продвинуться(); // Пропускаем открывающую кавычку
    
    while (!конец() && текущийСимвол() != U'"') {
        char32_t с = текущийСимвол();
        
        if (с == U'\n') {
            добавитьОшибку("Незакрытая строка");
            break;
        }
        
        if (с == U'\\') {
            // Escape-последовательность
            продвинуться();
            if (конец()) {
                добавитьОшибку("Неожиданный конец файла в escape-последовательности");
                break;
            }
            
            char32_t esc = текущийСимвол();
            switch (esc) {
                case U'n': значение += '\n'; текст += "\\n"; break;
                case U't': значение += '\t'; текст += "\\t"; break;
                case U'r': значение += '\r'; текст += "\\r"; break;
                case U'\\': значение += '\\'; текст += "\\\\"; break;
                case U'"': значение += '"'; текст += "\\\""; break;
                default:
                    добавитьОшибку("Неизвестная escape-последовательность");
                    break;
            }
            продвинуться();
        } else {
            // Обычный символ (UTF-8)
            size_t длина = длинаUTF8(исходник_[текущий_]);
            значение.append(исходник_.data() + текущий_, длина);
            текст.append(исходник_.data() + текущий_, длина);
            продвинуться();
        }
    }
    
    if (!конец() && текущийСимвол() == U'"') {
        текст += '"';
        продвинуться();
    }
    
    return Токен(ТипТокена::Строка, значение, начало, текст);
}

Токен Лексер::сканироватьСимвол() {
    Позиция начало = позиция_;
    std::string текст;
    
    текст += '\'';
    продвинуться(); // Пропускаем открывающую кавычку
    
    if (конец() || текущийСимвол() == U'\'') {
        return токенОшибки("Пустой символьный литерал");
    }
    
    char32_t значение;
    
    if (текущийСимвол() == U'\\') {
        // Escape-последовательность
        продвинуться();
        if (конец()) {
            return токенОшибки("Неожиданный конец файла");
        }
        
        char32_t esc = текущийСимвол();
        switch (esc) {
            case U'n': значение = U'\n'; текст += "\\n"; break;
            case U't': значение = U'\t'; текст += "\\t"; break;
            case U'r': значение = U'\r'; текст += "\\r"; break;
            case U'\\': значение = U'\\'; текст += "\\\\"; break;
            case U'\'': значение = U'\''; текст += "\\'"; break;
            default:
                return токенОшибки("Неизвестная escape-последовательность");
        }
        продвинуться();
    } else {
        значение = текущийСимвол();
        size_t длина = длинаUTF8(исходник_[текущий_]);
        текст.append(исходник_.data() + текущий_, длина);
        продвинуться();
    }
    
    if (конец() || текущийСимвол() != U'\'') {
        return токенОшибки("Ожидалась закрывающая кавычка");
    }
    
    текст += '\'';
    продвинуться();
    
    return Токен(ТипТокена::Символ, значение, начало, текст);
}

Токен Лексер::сканироватьОператор() {
    Позиция начало = позиция_;
    char32_t с = текущийСимвол();
    char32_t след = следующийСимвол();
    
    // Двухсимвольные операторы
    if (с == U'-' && след == U'>') {
        продвинуться(); продвинуться();
        return Токен(ТипТокена::Стрелка, начало, "->");
    }
    if (с == U'=' && след == U'>') {
        продвинуться(); продвинуться();
        return Токен(ТипТокена::ЖирнаяСтрелка, начало, "=>");
    }
    if (с == U'=' && след == U'=') {
        продвинуться(); продвинуться();
        return Токен(ТипТокена::ОпРавно, начало, "==");
    }
    if (с == U'!' && след == U'=') {
        продвинуться(); продвинуться();
        return Токен(ТипТокена::ОпНеРавно, начало, "!=");
    }
    if (с == U'<' && след == U'=') {
        продвинуться(); продвинуться();
        return Токен(ТипТокена::ОпМеньшеРавно, начало, "<=");
    }
    if (с == U'>' && след == U'=') {
        продвинуться(); продвинуться();
        return Токен(ТипТокена::ОпБольшеРавно, начало, ">=");
    }
    if (с == U'+' && след == U'=') {
        продвинуться(); продвинуться();
        return Токен(ТипТокена::ОпПлюсПрисвоить, начало, "+=");
    }
    if (с == U'-' && след == U'=') {
        продвинуться(); продвинуться();
        return Токен(ТипТокена::ОпМинусПрисвоить, начало, "-=");
    }
    if (с == U'&' && след == U'&') {
        продвинуться(); продвинуться();
        // Проверяем тройной &&&
        if (текущийСимвол() == U'&') {
            продвинуться();
            return Токен(ТипТокена::ОпКонсенсус, начало, "&&&");
        }
        return Токен(ТипТокена::ОпИ, начало, "&&");
    }
    if (с == U'|' && след == U'|') {
        продвинуться(); продвинуться();
        return Токен(ТипТокена::ОпИли, начало, "||");
    }
    if (с == U'.' && след == U'.') {
        продвинуться(); продвинуться();
        return Токен(ТипТокена::Диапазон, начало, "..");
    }
    
    // Односимвольные операторы
    продвинуться();
    
    switch (с) {
        case U'+': return Токен(ТипТокена::ОпПлюс, начало, "+");
        case U'-': return Токен(ТипТокена::ОпМинус, начало, "-");
        case U'*': return Токен(ТипТокена::ОпУмножить, начало, "*");
        case U'/': return Токен(ТипТокена::ОпДелить, начало, "/");
        case U'%': return Токен(ТипТокена::ОпОстаток, начало, "%");
        case U'<': return Токен(ТипТокена::ОпМеньше, начало, "<");
        case U'>': return Токен(ТипТокена::ОпБольше, начало, ">");
        case U'=': return Токен(ТипТокена::ОпПрисвоить, начало, "=");
        case U'!': return Токен(ТипТокена::ОпНе, начало, "!");
        case U'(': return Токен(ТипТокена::СкобкаКруглаяОткр, начало, "(");
        case U')': return Токен(ТипТокена::СкобкаКруглаяЗакр, начало, ")");
        case U'{': return Токен(ТипТокена::СкобкаФигурнаяОткр, начало, "{");
        case U'}': return Токен(ТипТокена::СкобкаФигурнаяЗакр, начало, "}");
        case U'[': return Токен(ТипТокена::СкобкаКвадратнаяОткр, начало, "[");
        case U']': return Токен(ТипТокена::СкобкаКвадратнаяЗакр, начало, "]");
        case U',': return Токен(ТипТокена::Запятая, начало, ",");
        case U'.': return Токен(ТипТокена::Точка, начало, ".");
        case U':': return Токен(ТипТокена::Двоеточие, начало, ":");
        case U';': return Токен(ТипТокена::ТочкаЗапятая, начало, ";");
        case U'|': return Токен(ТипТокена::Вертикальная, начало, "|");
        case U'&': return Токен(ТипТокена::Амперсанд, начало, "&");
        default:
            return токенОшибки("Неизвестный символ");
    }
}

// === Проверки символов ===

bool Лексер::началоИдентификатора(char32_t с) {
    // Латиница, кириллица, подчёркивание
    if (с == U'_') return true;
    if (с >= U'a' && с <= U'z') return true;
    if (с >= U'A' && с <= U'Z') return true;
    if (с >= U'\u0410' && с <= U'\u044F') return true; // А-я
    if (с == U'\u0401' || с == U'\u0451') return true; // Ё, ё
    return false;
}

bool Лексер::продолжениеИдентификатора(char32_t с) {
    return началоИдентификатора(с) || цифра(с);
}

bool Лексер::цифра(char32_t с) {
    return с >= U'0' && с <= U'9';
}

bool Лексер::пробел(char32_t с) {
    return с == U' ' || с == U'\t' || с == U'\n' || с == U'\r';
}

void Лексер::добавитьОшибку(const std::string& сообщение) {
    ошибки_.emplace_back(сообщение, позиция_);
}

Токен Лексер::токенОшибки(const std::string& сообщение) {
    добавитьОшибку(сообщение);
    return Токен(ТипТокена::Ошибка, сообщение, позиция_, "");
}

// === UTF-8 ===

size_t Лексер::длинаUTF8(char первыйБайт) {
    unsigned char б = static_cast<unsigned char>(первыйБайт);
    if ((б & 0x80) == 0) return 1;      // 0xxxxxxx
    if ((б & 0xE0) == 0xC0) return 2;   // 110xxxxx
    if ((б & 0xF0) == 0xE0) return 3;   // 1110xxxx
    if ((б & 0xF8) == 0xF0) return 4;   // 11110xxx
    return 1; // Некорректный UTF-8, обрабатываем как 1 байт
}

char32_t Лексер::декодироватьUTF8(const char* данные, size_t& длина) {
    unsigned char б0 = static_cast<unsigned char>(данные[0]);
    
    if ((б0 & 0x80) == 0) {
        длина = 1;
        return static_cast<char32_t>(б0);
    }
    
    if ((б0 & 0xE0) == 0xC0) {
        длина = 2;
        unsigned char б1 = static_cast<unsigned char>(данные[1]);
        return ((б0 & 0x1F) << 6) | (б1 & 0x3F);
    }
    
    if ((б0 & 0xF0) == 0xE0) {
        длина = 3;
        unsigned char б1 = static_cast<unsigned char>(данные[1]);
        unsigned char б2 = static_cast<unsigned char>(данные[2]);
        return ((б0 & 0x0F) << 12) | ((б1 & 0x3F) << 6) | (б2 & 0x3F);
    }
    
    if ((б0 & 0xF8) == 0xF0) {
        длина = 4;
        unsigned char б1 = static_cast<unsigned char>(данные[1]);
        unsigned char б2 = static_cast<unsigned char>(данные[2]);
        unsigned char б3 = static_cast<unsigned char>(данные[3]);
        return ((б0 & 0x07) << 18) | ((б1 & 0x3F) << 12) | 
               ((б2 & 0x3F) << 6) | (б3 & 0x3F);
    }
    
    длина = 1;
    return U'\uFFFD'; // Replacement character
}

} // namespace Троица
