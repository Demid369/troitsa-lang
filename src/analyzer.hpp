/**
 * @file: analyzer.hpp
 * @description: Анализатор (парсер) языка "Троица"
 * @dependencies: lexer.hpp, tree.hpp
 * @created: 2026-02-02
 */

#ifndef T9_TROITSA_ANALYZER_HPP
#define T9_TROITSA_ANALYZER_HPP

#include "troitsa/lexer.hpp"
#include "troitsa/tree.hpp"
#include <vector>
#include <string>

namespace Троица {

/**
 * @brief Ошибка анализа
 */
struct ОшибкаАнализа {
    std::string сообщение;
    Позиция позиция;
    
    ОшибкаАнализа(std::string сооб, Позиция поз)
        : сообщение(std::move(сооб)), позиция(поз) {}
};

/**
 * @brief Анализатор (синтаксический анализатор / парсер)
 * 
 * Преобразует поток токенов в Древо (AST).
 * Использует метод рекурсивного спуска.
 * 
 * Приоритет операций (от низшего к высшему):
 *   1. ИЛИ, ||
 *   2. И, &&
 *   3. КОНСЕНСУС, &&&
 *   4. ==, !=
 *   5. <, >, <=, >=
 *   6. +, -
 *   7. *, /, %
 *   8. Унарные: -, НЕ, !
 *   9. Вызов, доступ, индекс
 */
class Анализатор {
public:
    /**
     * @brief Создать анализатор
     * @param лексер Лексер с исходным кодом
     */
    explicit Анализатор(Лексер& лексер);
    
    // === Основные методы ===
    
    /// Анализировать программу целиком
    [[nodiscard]] std::unique_ptr<Древо::Программа> анализировать();
    
    /// Анализировать одно выражение
    [[nodiscard]] Древо::УказательВыражение выражение();
    
    /// Анализировать одну инструкцию
    [[nodiscard]] Древо::УказательИнструкция инструкция();
    
    // === Информация ===
    
    /// Получить список ошибок
    [[nodiscard]] const std::vector<ОшибкаАнализа>& ошибки() const noexcept { return ошибки_; }
    
    /// Есть ли ошибки
    [[nodiscard]] bool естьОшибки() const noexcept { return !ошибки_.empty(); }

private:
    Лексер& лексер_;
    Токен текущий_;
    std::vector<ОшибкаАнализа> ошибки_;
    
    // === Работа с токенами ===
    
    /// Получить текущий токен
    [[nodiscard]] const Токен& текущийТокен() const noexcept { return текущий_; }
    
    /// Продвинуться к следующему токену
    void продвинуться();
    
    /// Проверить тип текущего токена
    [[nodiscard]] bool проверить(ТипТокена тип) const noexcept;
    
    /// Проверить и продвинуться если совпадает
    bool совпадает(ТипТокена тип);
    
    /// Ожидать токен определённого типа
    bool ожидать(ТипТокена тип, const std::string& сообщение);
    
    /// Добавить ошибку
    void ошибка(const std::string& сообщение);
    
    // === Выражения (по приоритету) ===
    
    [[nodiscard]] Древо::УказательВыражение выражениеИли();
    [[nodiscard]] Древо::УказательВыражение выражениеИ();
    [[nodiscard]] Древо::УказательВыражение выражениеКонсенсус();
    [[nodiscard]] Древо::УказательВыражение выражениеРавенство();
    [[nodiscard]] Древо::УказательВыражение выражениеСравнение();
    [[nodiscard]] Древо::УказательВыражение выражениеСложение();
    [[nodiscard]] Древо::УказательВыражение выражениеУмножение();
    [[nodiscard]] Древо::УказательВыражение выражениеУнарное();
    [[nodiscard]] Древо::УказательВыражение выражениеВызов();
    [[nodiscard]] Древо::УказательВыражение выражениеПервичное();
    
    // === Инструкции ===
    
    [[nodiscard]] Древо::УказательИнструкция инструкцияПусть();
    [[nodiscard]] Древо::УказательИнструкция инструкцияЕсли();
    [[nodiscard]] Древо::УказательИнструкция инструкцияВыбор();
    [[nodiscard]] Древо::УказательИнструкция инструкцияПока();
    [[nodiscard]] Древо::УказательИнструкция инструкцияДля();
    [[nodiscard]] Древо::УказательИнструкция инструкцияЦикл();
    [[nodiscard]] Древо::УказательИнструкция инструкцияВернуть();
    [[nodiscard]] Древо::УказательИнструкция инструкцияБлок();
    
    // === Объявления ===
    
    [[nodiscard]] Древо::УказательИнструкция объявлениеФункция();
    
    // === Вспомогательные ===
    
    /// Анализировать список аргументов вызова
    [[nodiscard]] std::vector<Древо::УказательВыражение> списокАргументов();
    
    /// Анализировать параметры функции
    [[nodiscard]] std::vector<Древо::Параметр> параметрыФункции();
    
    /// Анализировать тип
    [[nodiscard]] std::string типАннотация();
};

} // namespace Троица

#endif // T9_TROITSA_ANALYZER_HPP
