/**
 * @file: lexer.hpp
 * @description: Лексический анализатор языка "Троица"
 * @dependencies: token.hpp
 * @created: 2026-02-02
 */

#ifndef T9_TROITSA_LEXER_HPP
#define T9_TROITSA_LEXER_HPP

#include "troitsa/token.hpp"
#include <string>
#include <string_view>
#include <vector>
#include <unordered_map>
#include <optional>

namespace Троица {

/**
 * @brief Ошибка лексического анализа
 */
struct ОшибкаЛексера {
    std::string сообщение;
    Позиция позиция;
    
    ОшибкаЛексера(std::string сооб, Позиция поз)
        : сообщение(std::move(сооб)), позиция(поз) {}
};

/**
 * @brief Лексический анализатор языка "Троица"
 * 
 * Преобразует исходный код в поток токенов.
 * Поддерживает:
 *   - Русскоязычные идентификаторы и ключевые слова
 *   - Троичные литералы (0т+−0)
 *   - Unicode строки
 *   - Однострочные (//) и многострочные комментарии
 */
class Лексер {
public:
    /**
     * @brief Создать лексер для исходного кода
     * @param исходник Исходный код на языке "Троица"
     * @param имяФайла Имя файла (для сообщений об ошибках)
     */
    explicit Лексер(std::string_view исходник, std::string имяФайла = "<вход>");
    
    // === Основные методы ===
    
    /// Получить следующий токен
    [[nodiscard]] Токен следующийТокен();
    
    /// Посмотреть следующий токен без продвижения
    [[nodiscard]] Токен заглянуть();
    
    /// Токенизировать весь исходник
    [[nodiscard]] std::vector<Токен> токенизировать();
    
    /// Проверить, достигнут ли конец
    [[nodiscard]] bool конец() const noexcept;
    
    // === Информация ===
    
    /// Получить текущую позицию
    [[nodiscard]] Позиция позиция() const noexcept { return позиция_; }
    
    /// Получить список ошибок
    [[nodiscard]] const std::vector<ОшибкаЛексера>& ошибки() const noexcept { return ошибки_; }
    
    /// Есть ли ошибки
    [[nodiscard]] bool естьОшибки() const noexcept { return !ошибки_.empty(); }

private:
    std::string_view исходник_;
    std::string имяФайла_;
    size_t текущий_;            // Текущая позиция в байтах
    Позиция позиция_;
    std::vector<ОшибкаЛексера> ошибки_;
    std::optional<Токен> буфер_; // Для заглянуть()
    
    // Таблица ключевых слов
    static const std::unordered_map<std::string, ТипТокена> КЛЮЧЕВЫЕ_СЛОВА;
    
    // === Вспомогательные методы ===
    
    /// Получить текущий символ (Unicode code point)
    [[nodiscard]] char32_t текущийСимвол() const;
    
    /// Получить следующий символ без продвижения
    [[nodiscard]] char32_t следующийСимвол() const;
    
    /// Продвинуться на один символ
    void продвинуться();
    
    /// Пропустить пробелы и комментарии
    void пропуститьПробелы();
    
    /// Пропустить однострочный комментарий
    void пропуститьОднострочныйКомментарий();
    
    /// Пропустить многострочный комментарий
    void пропуститьМногострочныйКомментарий();
    
    // === Сканирование токенов ===
    
    /// Сканировать идентификатор или ключевое слово
    [[nodiscard]] Токен сканироватьИдентификатор();
    
    /// Сканировать число
    [[nodiscard]] Токен сканироватьЧисло();
    
    /// Сканировать троичный литерал (0т...)
    [[nodiscard]] Токен сканироватьТроичное();
    
    /// Сканировать строку
    [[nodiscard]] Токен сканироватьСтроку();
    
    /// Сканировать символ
    [[nodiscard]] Токен сканироватьСимвол();
    
    /// Сканировать оператор или разделитель
    [[nodiscard]] Токен сканироватьОператор();
    
    // === Проверки символов ===
    
    /// Является ли символ началом идентификатора
    [[nodiscard]] static bool началоИдентификатора(char32_t с);
    
    /// Является ли символ продолжением идентификатора
    [[nodiscard]] static bool продолжениеИдентификатора(char32_t с);
    
    /// Является ли символ цифрой
    [[nodiscard]] static bool цифра(char32_t с);
    
    /// Является ли символ пробельным
    [[nodiscard]] static bool пробел(char32_t с);
    
    /// Добавить ошибку
    void добавитьОшибку(const std::string& сообщение);
    
    /// Создать токен ошибки
    [[nodiscard]] Токен токенОшибки(const std::string& сообщение);
    
    // === UTF-8 ===
    
    /// Декодировать UTF-8 символ
    [[nodiscard]] static char32_t декодироватьUTF8(const char* данные, size_t& длина);
    
    /// Получить длину UTF-8 символа в байтах
    [[nodiscard]] static size_t длинаUTF8(char первыйБайт);
};

} // namespace Троица

#endif // T9_TROITSA_LEXER_HPP
