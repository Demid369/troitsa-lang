/**
 * @file: interpreter.cpp
 * @description: Реализация интерпретатора языка "Троица"
 * @dependencies: interpreter.hpp
 * @created: 2026-02-02
 */

#include "troitsa/interpreter.hpp"
#include "trinity/alu.hpp"
#include "trinity/gpg.hpp"
#include "trinity/extended_ops.hpp"
#include "trinity/tribonacci.hpp"
#include "trinity/float.hpp"
#include "trinity/toroidal_db.hpp"
#include <sstream>
#include <iostream>
#include <cmath>
#include <memory>

// Глобальный экземпляр тороидальной БД для интерпретатора
static std::unique_ptr<Тринити::ТороидальнаяБД> глобальнаяБД;

namespace Троица {

// =============================================================================
// Значение — преобразования
// =============================================================================

int64_t Значение::вЦелое() const {
    if (этоЦелое()) return какЦелое();
    if (этоДробное()) return static_cast<int64_t>(какДробное());
    if (этоТрит()) return какТрит().значение;
    if (этоГармония()) return какГармония().вЧисло();
    if (этоЛогика()) return какЛогика() ? 1 : -1;
    throw ОшибкаВыполнения("Невозможно преобразовать в целое");
}

ЗначениеТрит Значение::вТрит() const {
    if (этоТрит()) return какТрит();
    if (этоЦелое()) {
        int64_t ц = какЦелое();
        if (ц > 0) return ЗначениеТрит(1);
        if (ц < 0) return ЗначениеТрит(-1);
        return ЗначениеТрит(0);
    }
    if (этоГармония()) {
        int64_t ц = какГармония().вЧисло();
        if (ц > 0) return ЗначениеТрит(1);
        if (ц < 0) return ЗначениеТрит(-1);
        return ЗначениеТрит(0);
    }
    if (этоЛогика()) {
        return ЗначениеТрит(какЛогика() ? 1 : -1);
    }
    throw ОшибкаВыполнения("Невозможно преобразовать в Трит");
}

ЗначениеГармония Значение::вГармонию() const {
    if (этоГармония()) return какГармония();
    if (этоЦелое()) return ЗначениеГармония(какЦелое());
    if (этоТрит()) return ЗначениеГармония(какТрит().значение);
    throw ОшибкаВыполнения("Невозможно преобразовать в Гармонию");
}

std::string Значение::вСтроку() const {
    if (пусто()) return "пусто";
    if (этоТрит()) {
        switch (какТрит().значение) {
            case 1: return "Да";
            case -1: return "Нет";
            default: return "Может";
        }
    }
    if (этоГармония()) {
        std::ostringstream oss;
        oss << какГармония().вЧисло() << " [";
        for (int i = 8; i >= 0; --i) {
            int8_t т = какГармония().триты[i];
            oss << (т == 1 ? '+' : (т == -1 ? '-' : '0'));
        }
        oss << "]";
        return oss.str();
    }
    if (этоЦелое()) return std::to_string(какЦелое());
    if (этоДробное()) return std::to_string(какДробное());
    if (этоСтрока()) return какСтрока();
    if (этоСимвол()) {
        std::string результат;
        char32_t с = какСимвол();
        // Простое UTF-8 кодирование
        if (с < 0x80) {
            результат += static_cast<char>(с);
        } else if (с < 0x800) {
            результат += static_cast<char>(0xC0 | (с >> 6));
            результат += static_cast<char>(0x80 | (с & 0x3F));
        } else if (с < 0x10000) {
            результат += static_cast<char>(0xE0 | (с >> 12));
            результат += static_cast<char>(0x80 | ((с >> 6) & 0x3F));
            результат += static_cast<char>(0x80 | (с & 0x3F));
        } else {
            результат += static_cast<char>(0xF0 | (с >> 18));
            результат += static_cast<char>(0x80 | ((с >> 12) & 0x3F));
            результат += static_cast<char>(0x80 | ((с >> 6) & 0x3F));
            результат += static_cast<char>(0x80 | (с & 0x3F));
        }
        return результат;
    }
    if (этоЛогика()) return какЛогика() ? "истина" : "ложь";
    if (этоСписок()) {
        std::ostringstream oss;
        oss << "[";
        const auto& список = какСписок();
        for (size_t i = 0; i < список.size(); ++i) {
            if (i > 0) oss << ", ";
            oss << список[i].вСтроку();
        }
        oss << "]";
        return oss.str();
    }
    if (этоФункция()) return "<функция>";
    if (этоТрибоначчи()) return какТрибоначчи().вДесятичную();
    if (этоВещественное()) return какВещественное().вСтроку();
    return "<неизвестно>";
}

bool Значение::вЛогику() const {
    if (пусто()) return false;
    if (этоТрит()) return какТрит().да();  // Только Да = истина
    if (этоГармония()) return какГармония().вЧисло() > 0;
    if (этоЦелое()) return какЦелое() > 0;
    if (этоДробное()) return какДробное() > 0;
    if (этоСтрока()) return !какСтрока().empty();
    if (этоЛогика()) return какЛогика();
    if (этоСписок()) return !какСписок().empty();
    return true;  // Функции и прочее — истина
}

// =============================================================================
// СредаВыполнения
// =============================================================================

СредаВыполнения::СредаВыполнения(std::shared_ptr<СредаВыполнения> родитель)
    : родитель_(std::move(родитель))
{
}

void СредаВыполнения::определить(const std::string& имя, Значение значение) {
    переменные_[имя] = std::move(значение);
}

bool СредаВыполнения::присвоить(const std::string& имя, Значение значение) {
    auto it = переменные_.find(имя);
    if (it != переменные_.end()) {
        it->second = std::move(значение);
        return true;
    }
    if (родитель_) {
        return родитель_->присвоить(имя, std::move(значение));
    }
    return false;
}

Значение* СредаВыполнения::получить(const std::string& имя) {
    auto it = переменные_.find(имя);
    if (it != переменные_.end()) {
        return &it->second;
    }
    if (родитель_) {
        return родитель_->получить(имя);
    }
    return nullptr;
}

const Значение* СредаВыполнения::получить(const std::string& имя) const {
    auto it = переменные_.find(имя);
    if (it != переменные_.end()) {
        return &it->second;
    }
    if (родитель_) {
        return родитель_->получить(имя);
    }
    return nullptr;
}

bool СредаВыполнения::существует(const std::string& имя) const {
    if (переменные_.find(имя) != переменные_.end()) return true;
    if (родитель_) return родитель_->существует(имя);
    return false;
}

// =============================================================================
// Интерпретатор — основные методы
// =============================================================================

Интерпретатор::Интерпретатор() {
    глобальная_ = std::make_shared<СредаВыполнения>();
    текущая_ = глобальная_;
    
    // Обработчики по умолчанию
    обработчикВывода_ = [](const std::string& текст) {
        std::cout << текст << std::endl;
    };
    обработчикВвода_ = []() {
        std::string строка;
        std::getline(std::cin, строка);
        return строка;
    };
    
    зарегистрироватьВстроенные();
}

Значение Интерпретатор::выполнить(Древо::Программа& программа) {
    Значение результат;
    
    for (auto& объявление : программа.объявления) {
        выполнитьИнструкцию(объявление.get());
    }
    
    return результат;
}

void Интерпретатор::выполнитьИнструкцию(Древо::Инструкция* инструкция) {
    if (!инструкция) return;
    
    switch (инструкция->тип) {
        case Древо::ТипУзла::Пусть:
            выполнитьПусть(static_cast<Древо::Пусть*>(инструкция));
            break;
        case Древо::ТипУзла::Присвоить:
            выполнитьПрисвоить(static_cast<Древо::Присвоить*>(инструкция));
            break;
        case Древо::ТипУзла::Если:
            выполнитьЕсли(static_cast<Древо::Если*>(инструкция));
            break;
        case Древо::ТипУзла::Выбор:
            выполнитьВыбор(static_cast<Древо::Выбор*>(инструкция));
            break;
        case Древо::ТипУзла::Пока:
            выполнитьПока(static_cast<Древо::Пока*>(инструкция));
            break;
        case Древо::ТипУзла::Для:
            выполнитьДля(static_cast<Древо::Для*>(инструкция));
            break;
        case Древо::ТипУзла::Цикл:
            выполнитьЦикл(static_cast<Древо::Цикл*>(инструкция));
            break;
        case Древо::ТипУзла::Вернуть:
            выполнитьВернуть(static_cast<Древо::Вернуть*>(инструкция));
            break;
        case Древо::ТипУзла::Прервать:
            throw СигналПрервать();
        case Древо::ТипУзла::Продолжить:
            throw СигналПродолжить();
        case Древо::ТипУзла::Блок:
            выполнитьБлок(static_cast<Древо::Блок*>(инструкция));
            break;
        case Древо::ТипУзла::ОбъявФункция:
            выполнитьОбъявФункция(static_cast<Древо::ОбъявФункция*>(инструкция));
            break;
        case Древо::ТипУзла::ВыражениеИнструкция: {
            auto* выр = static_cast<Древо::ВыражениеИнструкция*>(инструкция);
            вычислить(выр->выражение.get());
            break;
        }
        default:
            break;
    }
}

Значение Интерпретатор::вычислить(Древо::Выражение* выражение) {
    if (!выражение) return Значение::Пусто();
    
    switch (выражение->тип) {
        case Древо::ТипУзла::Имя:
            return вычислитьИмя(static_cast<Древо::Имя*>(выражение));
        case Древо::ТипУзла::ЗначениеЧисло:
            return вычислитьЧисло(static_cast<Древо::ЗначениеЧисло*>(выражение));
        case Древо::ТипУзла::ЗначениеВещественное:
            return вычислитьВещественное(static_cast<Древо::ЗначениеВещественное*>(выражение));
        case Древо::ТипУзла::ЗначениеСтрока:
            return вычислитьСтрока(static_cast<Древо::ЗначениеСтрока*>(выражение));
        case Древо::ТипУзла::ЗначениеЛогика:
            return вычислитьЛогика(static_cast<Древо::ЗначениеЛогика*>(выражение));
        case Древо::ТипУзла::ДвойнаяОперация:
            return вычислитьДвойнаяОперация(static_cast<Древо::ДвойнаяОперация*>(выражение));
        case Древо::ТипУзла::ОднарнаяОперация:
            return вычислитьОднарнаяОперация(static_cast<Древо::ОднарнаяОперация*>(выражение));
        case Древо::ТипУзла::Вызов:
            return вычислитьВызов(static_cast<Древо::Вызов*>(выражение));
        case Древо::ТипУзла::Доступ:
            return вычислитьДоступ(static_cast<Древо::Доступ*>(выражение));
        case Древо::ТипУзла::Индекс:
            return вычислитьИндекс(static_cast<Древо::Индекс*>(выражение));
        default:
            return Значение::Пусто();
    }
}

void Интерпретатор::вывести(const std::string& текст) {
    if (обработчикВывода_) {
        обработчикВывода_(текст);
    }
}

std::string Интерпретатор::ввести() {
    if (обработчикВвода_) {
        return обработчикВвода_();
    }
    return "";
}

// =============================================================================
// Выполнение инструкций
// =============================================================================

void Интерпретатор::выполнитьПусть(Древо::Пусть* узел) {
    Значение значение = Значение::Пусто();
    if (узел->значение) {
        значение = вычислить(узел->значение.get());
    }
    текущая_->определить(узел->имя, std::move(значение));
}

void Интерпретатор::выполнитьПрисвоить(Древо::Присвоить* узел) {
    Значение значение = вычислить(узел->значение.get());
    
    if (auto* имя = dynamic_cast<Древо::Имя*>(узел->цель.get())) {
        if (!текущая_->присвоить(имя->имя, std::move(значение))) {
            throw ОшибкаВыполнения("Неизвестная переменная: " + имя->имя, узел->позиция);
        }
    } else {
        throw ОшибкаВыполнения("Недопустимая цель присваивания", узел->позиция);
    }
}

void Интерпретатор::выполнитьЕсли(Древо::Если* узел) {
    Значение условие = вычислить(узел->условие.get());
    
    // Троичная логика: Да = истина, Нет и Может = ложь
    bool истина = условие.вЛогику();
    
    if (истина) {
        войтиВСреду();
        выполнитьИнструкцию(узел->тогда.get());
        выйтиИзСреды();
    } else if (узел->иначе) {
        войтиВСреду();
        выполнитьИнструкцию(узел->иначе.get());
        выйтиИзСреды();
    }
}

void Интерпретатор::выполнитьВыбор(Древо::Выбор* узел) {
    Значение значение = вычислить(узел->значение.get());
    
    for (auto& ветка : узел->ветки) {
        if (!ветка.образец) continue;
        
        Значение образец = вычислить(ветка.образец.get());
        
        // Сравниваем значения
        bool совпадение = false;
        if (значение.этоТрит() && образец.этоТрит()) {
            совпадение = значение.какТрит().значение == образец.какТрит().значение;
        } else if (значение.этоЦелое() && образец.этоЦелое()) {
            совпадение = значение.какЦелое() == образец.какЦелое();
        } else if (значение.этоСтрока() && образец.этоСтрока()) {
            совпадение = значение.какСтрока() == образец.какСтрока();
        }
        
        if (совпадение) {
            войтиВСреду();
            выполнитьИнструкцию(ветка.тело.get());
            выйтиИзСреды();
            return;
        }
    }
}

void Интерпретатор::выполнитьПока(Древо::Пока* узел) {
    while (true) {
        Значение условие = вычислить(узел->условие.get());
        if (!условие.вЛогику()) break;
        
        try {
            войтиВСреду();
            выполнитьИнструкцию(узел->тело.get());
            выйтиИзСреды();
        } catch (const СигналПрервать&) {
            выйтиИзСреды();
            break;
        } catch (const СигналПродолжить&) {
            выйтиИзСреды();
            continue;
        }
    }
}

void Интерпретатор::выполнитьДля(Древо::Для* узел) {
    Значение коллекция = вычислить(узел->коллекция.get());
    
    if (коллекция.этоСписок()) {
        for (const auto& элемент : коллекция.какСписок()) {
            try {
                войтиВСреду();
                текущая_->определить(узел->переменная, элемент);
                выполнитьИнструкцию(узел->тело.get());
                выйтиИзСреды();
            } catch (const СигналПрервать&) {
                выйтиИзСреды();
                break;
            } catch (const СигналПродолжить&) {
                выйтиИзСреды();
                continue;
            }
        }
    } else if (коллекция.этоСтрока()) {
        // Итерация по символам строки
        const std::string& строка = коллекция.какСтрока();
        for (char с : строка) {
            try {
                войтиВСреду();
                текущая_->определить(узел->переменная, Значение(static_cast<char32_t>(с)));
                выполнитьИнструкцию(узел->тело.get());
                выйтиИзСреды();
            } catch (const СигналПрервать&) {
                выйтиИзСреды();
                break;
            } catch (const СигналПродолжить&) {
                выйтиИзСреды();
                continue;
            }
        }
    } else if (коллекция.этоГармония()) {
        // Итерация по тритам Гармонии
        const auto& гармония = коллекция.какГармония();
        for (int i = 0; i < 9; ++i) {
            try {
                войтиВСреду();
                текущая_->определить(узел->переменная, Значение(ЗначениеТрит(гармония.триты[i])));
                выполнитьИнструкцию(узел->тело.get());
                выйтиИзСреды();
            } catch (const СигналПрервать&) {
                выйтиИзСреды();
                break;
            } catch (const СигналПродолжить&) {
                выйтиИзСреды();
                continue;
            }
        }
    } else {
        throw ОшибкаВыполнения("Невозможно итерировать по данному типу", узел->позиция);
    }
}

void Интерпретатор::выполнитьЦикл(Древо::Цикл* узел) {
    while (true) {
        try {
            войтиВСреду();
            выполнитьИнструкцию(узел->тело.get());
            выйтиИзСреды();
        } catch (const СигналПрервать&) {
            выйтиИзСреды();
            break;
        } catch (const СигналПродолжить&) {
            выйтиИзСреды();
            continue;
        }
    }
}

void Интерпретатор::выполнитьВернуть(Древо::Вернуть* узел) {
    Значение значение = Значение::Пусто();
    if (узел->значение) {
        значение = вычислить(узел->значение.get());
    }
    throw СигналВозврат(std::move(значение));
}

void Интерпретатор::выполнитьБлок(Древо::Блок* узел) {
    войтиВСреду();
    for (auto& инструкция : узел->инструкции) {
        выполнитьИнструкцию(инструкция.get());
    }
    выйтиИзСреды();
}

void Интерпретатор::выполнитьОбъявФункция(Древо::ОбъявФункция* узел) {
    auto функция = std::make_shared<ПользовательскаяФункция>();
    
    for (const auto& параметр : узел->параметры) {
        функция->параметры.push_back(параметр.имя);
    }
    функция->тело = узел->тело.get();
    функция->замыкание = текущая_;
    
    текущая_->определить(узел->имя, Значение(функция));
}

// =============================================================================
// Вычисление выражений
// =============================================================================

Значение Интерпретатор::вычислитьИмя(Древо::Имя* узел) {
    Значение* значение = текущая_->получить(узел->имя);
    if (!значение) {
        throw ОшибкаВыполнения("Неизвестная переменная: " + узел->имя, узел->позиция);
    }
    return *значение;
}

Значение Интерпретатор::вычислитьЧисло(Древо::ЗначениеЧисло* узел) {
    if (узел->троичное) {
        int64_t знач = узел->значение;
        if (знач >= -1 && знач <= 1) {
            return Значение::Трит(static_cast<int8_t>(знач));
        }
        return Значение::Гармония(знач);
    }
    return Значение::Целое(узел->значение);
}

Значение Интерпретатор::вычислитьВещественное(Древо::ЗначениеВещественное* узел) {
    return Значение::Вещественное(узел->значение);
}

Значение Интерпретатор::вычислитьСтрока(Древо::ЗначениеСтрока* узел) {
    return Значение::Строка(узел->значение);
}

Значение Интерпретатор::вычислитьЛогика(Древо::ЗначениеЛогика* узел) {
    return Значение::Трит(узел->значение);
}

Значение Интерпретатор::вычислитьДвойнаяОперация(Древо::ДвойнаяОперация* узел) {
    Значение левое = вычислить(узел->левое.get());
    Значение правое = вычислить(узел->правое.get());
    
    switch (узел->оператор) {
        case ТипТокена::ОпПлюс:
            return сложить(левое, правое);
        case ТипТокена::ОпМинус:
            return вычесть(левое, правое);
        case ТипТокена::ОпУмножить:
            return умножить(левое, правое);
        case ТипТокена::ОпДелить:
            return разделить(левое, правое);
        case ТипТокена::ОпОстаток:
            return остаток(левое, правое);
        case ТипТокена::ОпРавно:
        case ТипТокена::ОпНеРавно:
        case ТипТокена::ОпМеньше:
        case ТипТокена::ОпБольше:
        case ТипТокена::ОпМеньшеРавно:
        case ТипТокена::ОпБольшеРавно:
            return сравнить(узел->оператор, левое, правое);
        case ТипТокена::ОпИ:
        case ТипТокена::ОпИли:
        case ТипТокена::ОпКонсенсус:
            return логическаяОперация(узел->оператор, левое, правое);
        default:
            throw ОшибкаВыполнения("Неизвестный оператор", узел->позиция);
    }
}

Значение Интерпретатор::вычислитьОднарнаяОперация(Древо::ОднарнаяОперация* узел) {
    Значение операнд = вычислить(узел->операнд.get());
    
    switch (узел->оператор) {
        case ТипТокена::ОпМинус:
            if (операнд.этоЦелое()) {
                return Значение::Целое(-операнд.какЦелое());
            }
            if (операнд.этоТрит()) {
                return Значение(операнд.какТрит().не());
            }
            if (операнд.этоГармония()) {
                return Значение::Гармония(-операнд.какГармония().вЧисло());
            }
            throw ОшибкаВыполнения("Невозможно применить унарный минус", узел->позиция);
            
        case ТипТокена::ОпНе:
            if (операнд.этоТрит()) {
                return Значение(операнд.какТрит().не());
            }
            if (операнд.этоЛогика()) {
                return Значение(!операнд.какЛогика());
            }
            // Для других типов — инверсия логического значения
            return Значение::Трит(операнд.вЛогику() ? -1 : 1);
            
        default:
            throw ОшибкаВыполнения("Неизвестный унарный оператор", узел->позиция);
    }
}

Значение Интерпретатор::вычислитьВызов(Древо::Вызов* узел) {
    Значение функция = вычислить(узел->функция.get());
    
    std::vector<Значение> аргументы;
    for (auto& арг : узел->аргументы) {
        аргументы.push_back(вычислить(арг.get()));
    }
    
    return вызватьФункцию(функция, аргументы);
}

Значение Интерпретатор::вызватьФункцию(const Значение& функция, const std::vector<Значение>& аргументы) {
    // Встроенная функция
    if (std::holds_alternative<ВстроеннаяФункция>(функция.данные())) {
        auto& встроенная = std::get<ВстроеннаяФункция>(функция.данные());
        return встроенная(*this, аргументы);
    }
    
    // Пользовательская функция
    if (std::holds_alternative<std::shared_ptr<ПользовательскаяФункция>>(функция.данные())) {
        auto& пользовательская = std::get<std::shared_ptr<ПользовательскаяФункция>>(функция.данные());
        
        // Создаём новую среду на основе замыкания
        auto предыдущая = текущая_;
        текущая_ = std::make_shared<СредаВыполнения>(пользовательская->замыкание);
        
        // Связываем параметры с аргументами
        for (size_t i = 0; i < пользовательская->параметры.size(); ++i) {
            Значение значение = i < аргументы.size() ? аргументы[i] : Значение::Пусто();
            текущая_->определить(пользовательская->параметры[i], std::move(значение));
        }
        
        Значение результат = Значение::Пусто();
        try {
            выполнитьИнструкцию(пользовательская->тело);
        } catch (const СигналВозврат& возврат) {
            результат = возврат.значение();
        }
        
        текущая_ = предыдущая;
        return результат;
    }
    
    throw ОшибкаВыполнения("Попытка вызвать не-функцию");
}

Значение Интерпретатор::вычислитьДоступ(Древо::Доступ* узел) {
    // TODO: Реализовать доступ к полям
    throw ОшибкаВыполнения("Доступ к полям пока не реализован", узел->позиция);
}

Значение Интерпретатор::вычислитьИндекс(Древо::Индекс* узел) {
    Значение объект = вычислить(узел->объект.get());
    Значение индекс = вычислить(узел->индекс.get());
    
    int64_t и = индекс.вЦелое();
    
    if (объект.этоСписок()) {
        const auto& список = объект.какСписок();
        if (и < 0 || static_cast<size_t>(и) >= список.size()) {
            throw ОшибкаВыполнения("Индекс за пределами списка", узел->позиция);
        }
        return список[и];
    }
    
    if (объект.этоСтрока()) {
        const auto& строка = объект.какСтрока();
        if (и < 0 || static_cast<size_t>(и) >= строка.size()) {
            throw ОшибкаВыполнения("Индекс за пределами строки", узел->позиция);
        }
        return Значение(static_cast<char32_t>(строка[и]));
    }
    
    if (объект.этоГармония()) {
        if (и < 0 || и >= 9) {
            throw ОшибкаВыполнения("Индекс трита должен быть 0-8", узел->позиция);
        }
        return Значение(объект.какГармония().трит(и));
    }
    
    throw ОшибкаВыполнения("Невозможно индексировать данный тип", узел->позиция);
}

// =============================================================================
// Операции
// =============================================================================

Значение Интерпретатор::сложить(const Значение& а, const Значение& б) {
    // Конкатенация строк
    if (а.этоСтрока() || б.этоСтрока()) {
        return Значение::Строка(а.вСтроку() + б.вСтроку());
    }
    
    // Троичное сложение
    if (а.этоТрит() && б.этоТрит()) {
        int сумма = а.какТрит().значение + б.какТрит().значение;
        if (сумма > 1) сумма = -1;  // Переполнение вверх
        if (сумма < -1) сумма = 1;  // Переполнение вниз
        return Значение::Трит(static_cast<int8_t>(сумма));
    }
    
    // Гармония
    if (а.этоГармония() || б.этоГармония()) {
        return Значение::Гармония(а.вГармонию().вЧисло() + б.вГармонию().вЧисло());
    }
    
    // Целые числа
    return Значение::Целое(а.вЦелое() + б.вЦелое());
}

Значение Интерпретатор::вычесть(const Значение& а, const Значение& б) {
    if (а.этоТрит() && б.этоТрит()) {
        int разность = а.какТрит().значение - б.какТрит().значение;
        if (разность > 1) разность = -1;
        if (разность < -1) разность = 1;
        return Значение::Трит(static_cast<int8_t>(разность));
    }
    
    if (а.этоГармония() || б.этоГармония()) {
        return Значение::Гармония(а.вГармонию().вЧисло() - б.вГармонию().вЧисло());
    }
    
    return Значение::Целое(а.вЦелое() - б.вЦелое());
}

Значение Интерпретатор::умножить(const Значение& а, const Значение& б) {
    if (а.этоТрит() && б.этоТрит()) {
        return Значение::Трит(static_cast<int8_t>(а.какТрит().значение * б.какТрит().значение));
    }
    
    if (а.этоГармония() || б.этоГармония()) {
        return Значение::Гармония(а.вГармонию().вЧисло() * б.вГармонию().вЧисло());
    }
    
    return Значение::Целое(а.вЦелое() * б.вЦелое());
}

Значение Интерпретатор::разделить(const Значение& а, const Значение& б) {
    int64_t делитель = б.вЦелое();
    if (делитель == 0) {
        throw ОшибкаВыполнения("Деление на ноль");
    }
    
    if (а.этоГармония() || б.этоГармония()) {
        return Значение::Гармония(а.вГармонию().вЧисло() / делитель);
    }
    
    return Значение::Целое(а.вЦелое() / делитель);
}

Значение Интерпретатор::остаток(const Значение& а, const Значение& б) {
    int64_t делитель = б.вЦелое();
    if (делитель == 0) {
        throw ОшибкаВыполнения("Деление на ноль");
    }
    return Значение::Целое(а.вЦелое() % делитель);
}

Значение Интерпретатор::сравнить(ТипТокена оп, const Значение& а, const Значение& б) {
    // Сравнение строк
    if (а.этоСтрока() && б.этоСтрока()) {
        const auto& са = а.какСтрока();
        const auto& сб = б.какСтрока();
        
        switch (оп) {
            case ТипТокена::ОпРавно: return Значение::Трит(са == сб ? 1 : -1);
            case ТипТокена::ОпНеРавно: return Значение::Трит(са != сб ? 1 : -1);
            case ТипТокена::ОпМеньше: return Значение::Трит(са < сб ? 1 : -1);
            case ТипТокена::ОпБольше: return Значение::Трит(са > сб ? 1 : -1);
            case ТипТокена::ОпМеньшеРавно: return Значение::Трит(са <= сб ? 1 : -1);
            case ТипТокена::ОпБольшеРавно: return Значение::Трит(са >= сб ? 1 : -1);
            default: break;
        }
    }
    
    // Сравнение чисел
    int64_t ца = а.вЦелое();
    int64_t цб = б.вЦелое();
    
    switch (оп) {
        case ТипТокена::ОпРавно: return Значение::Трит(ца == цб ? 1 : -1);
        case ТипТокена::ОпНеРавно: return Значение::Трит(ца != цб ? 1 : -1);
        case ТипТокена::ОпМеньше: return Значение::Трит(ца < цб ? 1 : -1);
        case ТипТокена::ОпБольше: return Значение::Трит(ца > цб ? 1 : -1);
        case ТипТокена::ОпМеньшеРавно: return Значение::Трит(ца <= цб ? 1 : -1);
        case ТипТокена::ОпБольшеРавно: return Значение::Трит(ца >= цб ? 1 : -1);
        default: return Значение::Может();
    }
}

Значение Интерпретатор::логическаяОперация(ТипТокена оп, const Значение& а, const Значение& б) {
    ЗначениеТрит та = а.вТрит();
    ЗначениеТрит тб = б.вТрит();
    
    switch (оп) {
        case ТипТокена::ОпИ:
            return Значение(та.и(тб));
        case ТипТокена::ОпИли:
            return Значение(та.или(тб));
        case ТипТокена::ОпКонсенсус:
            return Значение(та.консенсус(тб));
        default:
            return Значение::Может();
    }
}

// =============================================================================
// Вспомогательные методы
// =============================================================================

void Интерпретатор::войтиВСреду() {
    текущая_ = std::make_shared<СредаВыполнения>(текущая_);
}

void Интерпретатор::выйтиИзСреды() {
    if (текущая_->родитель()) {
        текущая_ = текущая_->родитель();
    }
}

void Интерпретатор::зарегистрироватьВстроенные() {
    // печать(значение)
    глобальная_->определить("печать", Значение(ВстроеннаяФункция(
        [](Интерпретатор& интерп, const std::vector<Значение>& арг) -> Значение {
            std::string вывод;
            for (size_t i = 0; i < арг.size(); ++i) {
                if (i > 0) вывод += " ";
                вывод += арг[i].вСтроку();
            }
            интерп.вывести(вывод);
            return Значение::Пусто();
        }
    )));
    
    // ввод() -> Строка
    глобальная_->определить("ввод", Значение(ВстроеннаяФункция(
        [](Интерпретатор& интерп, const std::vector<Значение>&) -> Значение {
            return Значение::Строка(интерп.ввести());
        }
    )));
    
    // вТрит(число) -> Трит
    глобальная_->определить("вТрит", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Может();
            return Значение(арг[0].вТрит());
        }
    )));
    
    // вГармонию(число) -> Гармония
    глобальная_->определить("вГармонию", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Гармония(0);
            return Значение(арг[0].вГармонию());
        }
    )));
    
    // модуль(число) -> число
    глобальная_->определить("модуль", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Целое(0);
            int64_t значение = арг[0].вЦелое();
            return Значение::Целое(значение < 0 ? -значение : значение);
        }
    )));
    
    // консенсус(а, б) -> Трит
    глобальная_->определить("консенсус", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.size() < 2) return Значение::Может();
            ЗначениеТрит а = арг[0].вТрит();
            ЗначениеТрит б = арг[1].вТрит();
            return Значение(а.консенсус(б));
        }
    )));
    
    // длина(коллекция) -> Целое
    глобальная_->определить("длина", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Целое(0);
            if (арг[0].этоСтрока()) {
                return Значение::Целое(static_cast<int64_t>(арг[0].какСтрока().size()));
            }
            if (арг[0].этоСписок()) {
                return Значение::Целое(static_cast<int64_t>(арг[0].какСписок().size()));
            }
            if (арг[0].этоГармония()) {
                return Значение::Целое(9);  // Гармония всегда 9 тритов
            }
            return Значение::Целое(1);
        }
    )));
    
    // список(...) -> Список
    глобальная_->определить("список", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            return Значение(арг);
        }
    )));
    
    // диапазон(от, до) -> Список
    глобальная_->определить("диапазон", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            int64_t от = 0, до = 0;
            if (арг.size() >= 1) от = арг[0].вЦелое();
            if (арг.size() >= 2) до = арг[1].вЦелое();
            
            std::vector<Значение> результат;
            if (от <= до) {
                for (int64_t i = от; i < до; ++i) {
                    результат.push_back(Значение::Целое(i));
                }
            } else {
                for (int64_t i = от; i > до; --i) {
                    результат.push_back(Значение::Целое(i));
                }
            }
            return Значение(std::move(результат));
        }
    )));
    
    // =========================================================================
    // Функции паттернов 369
    // =========================================================================
    
    // цифр_корень(число) -> Гармония
    // Вычисляет цифровой корень числа (Digital Root)
    // Пример: цифр_корень(369) -> 9
    глобальная_->определить("цифр_корень", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Гармония(0);
            int64_t значение = арг[0].вЦелое();
            auto результат = Тринити::АЛУ::ЦифровойКорень(Тринити::Гармония(static_cast<int>(значение)));
            return Значение::Гармония(результат.значение.вЧисло());
        }
    )));
    
    // группа_369(число) -> Трит
    // Проверяет принадлежность к группе 369
    // Возвращает: Да если DR ∈ {3,6,9}, Нет если DR ∈ {1,2,4,5,7,8}, Может если 0
    глобальная_->определить("группа_369", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Может();
            int64_t значение = арг[0].вЦелое();
            auto результат = Тринити::АЛУ::ПринадлежитГруппе369(Тринити::Гармония(static_cast<int>(значение)));
            return Значение::Трит(static_cast<int8_t>(результат.значение.вЧисло()));
        }
    )));
    
    // баланс(число) -> Трит
    // Приводит число к троичному значению: положительное -> Да, отрицательное -> Нет, ноль -> Может
    глобальная_->определить("баланс", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Может();
            int64_t значение = арг[0].вЦелое();
            auto результат = Тринити::АЛУ::Баланс(Тринити::Гармония(static_cast<int>(значение)));
            return Значение::Трит(static_cast<int8_t>(результат.значение.вЧисло()));
        }
    )));
    
    // =========================================================================
    // Функции Фибоначчи
    // =========================================================================
    
    // фибоначчи(n) -> Гармония
    // Возвращает n-е число Фибоначчи (F(1)=1, F(2)=1, F(3)=2...)
    глобальная_->определить("фибоначчи", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Гармония(1);
            int64_t n = арг[0].вЦелое();
            if (n < 1) n = 1;
            if (n > 20) n = 20;
            auto результат = Тринити::АЛУ::ЧислоФибоначчи(static_cast<size_t>(n));
            return Значение::Гармония(результат.вЧисло());
        }
    )));
    
    // фибо_умножить(число, n) -> Гармония
    // Умножает число на F(n)
    глобальная_->определить("фибо_умножить", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.size() < 2) return Значение::Гармония(0);
            int64_t значение = арг[0].вЦелое();
            int64_t n = арг[1].вЦелое();
            if (n < 1) n = 1;
            if (n > 20) n = 20;
            auto результат = Тринити::АЛУ::УмножитьНаФибоначчи(
                Тринити::Гармония(static_cast<int>(значение)), 
                static_cast<size_t>(n)
            );
            return Значение::Гармония(результат.значение.вЧисло());
        }
    )));
    
    // фибо_делить(число, n) -> Гармония
    // Делит число на F(n)
    глобальная_->определить("фибо_делить", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.size() < 2) return Значение::Гармония(0);
            int64_t значение = арг[0].вЦелое();
            int64_t n = арг[1].вЦелое();
            if (n < 1) n = 1;
            if (n > 20) n = 20;
            auto результат = Тринити::АЛУ::ДелитьНаФибоначчи(
                Тринити::Гармония(static_cast<int>(значение)), 
                static_cast<size_t>(n)
            );
            return Значение::Гармония(результат.значение.вЧисло());
        }
    )));
    
    // =========================================================================
    // Функции золотого сечения
    // =========================================================================
    
    // сдвиг_фи(число, направление) -> Гармония
    // Умножает (направление > 0) или делит (направление < 0) на φ
    // Использует приближение 21/13 ≈ 1.615
    глобальная_->определить("сдвиг_фи", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Гармония(0);
            int64_t значение = арг[0].вЦелое();
            bool влево = true;
            if (арг.size() >= 2) {
                влево = арг[1].вЦелое() >= 0;
            }
            auto результат = Тринити::АЛУ::СдвигФи(
                Тринити::Гармония(static_cast<int>(значение)), 
                влево
            );
            return Значение::Гармония(результат.значение.вЧисло());
        }
    )));
    
    // умножить_фи(число) -> Гармония
    // Умножает на φ (золотое сечение)
    глобальная_->определить("умножить_фи", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Гармония(0);
            int64_t значение = арг[0].вЦелое();
            auto результат = Тринити::АЛУ::СдвигФи(
                Тринити::Гармония(static_cast<int>(значение)), 
                true
            );
            return Значение::Гармония(результат.значение.вЧисло());
        }
    )));
    
    // делить_фи(число) -> Гармония
    // Делит на φ (золотое сечение)
    глобальная_->определить("делить_фи", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Гармония(0);
            int64_t значение = арг[0].вЦелое();
            auto результат = Тринити::АЛУ::СдвигФи(
                Тринити::Гармония(static_cast<int>(значение)), 
                false
            );
            return Значение::Гармония(результат.значение.вЧисло());
        }
    )));
    
    // =========================================================================
    // Тип Трибоначчи (27 тритов) - большие числа
    // =========================================================================
    
    // трибоначчи(число) -> Трибоначчи
    // Создаёт Трибоначчи из числа (диапазон ±3.8 триллиона)
    глобальная_->определить("трибоначчи", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Трибоначчи(0);
            int64_t значение = арг[0].вЦелое();
            return Значение::Трибоначчи(значение);
        }
    )));
    
    // триб_сложить(а, б) -> Трибоначчи
    // Сложение двух Трибоначчи
    глобальная_->определить("триб_сложить", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.size() < 2) return Значение::Трибоначчи(0);
            Тринити::Трибоначчи а(арг[0].вЦелое());
            Тринити::Трибоначчи б(арг[1].вЦелое());
            return Значение(а + б);
        }
    )));
    
    // триб_вычесть(а, б) -> Трибоначчи
    // Вычитание двух Трибоначчи
    глобальная_->определить("триб_вычесть", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.size() < 2) return Значение::Трибоначчи(0);
            Тринити::Трибоначчи а(арг[0].вЦелое());
            Тринити::Трибоначчи б(арг[1].вЦелое());
            return Значение(а - б);
        }
    )));
    
    // триб_число(n) -> Трибоначчи
    // Возвращает n-е число последовательности Трибоначчи
    // T(n) = T(n-1) + T(n-2) + T(n-3), T(0)=0, T(1)=0, T(2)=1
    глобальная_->определить("триб_число", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Трибоначчи(0);
            int64_t n = арг[0].вЦелое();
            if (n < 0) n = 0;
            if (n > 50) n = 50;  // Ограничение для безопасности
            auto результат = Тринити::ПоследовательностьТрибоначчи::Получить(static_cast<size_t>(n));
            return Значение(результат);
        }
    )));
    
    // триб_это_число(x) -> Трит
    // Проверяет, является ли x числом Трибоначчи
    глобальная_->определить("триб_это_число", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Может();
            Тринити::Трибоначчи т(арг[0].вЦелое());
            bool результат = Тринити::ПоследовательностьТрибоначчи::Является(т);
            return Значение::Трит(результат ? 1 : -1);
        }
    )));
    
    // =========================================================================
    // Тип Вещественное (27 тритов) - дробные числа
    // =========================================================================
    
    // вещественное(число) -> Вещественное
    // Создаёт Вещественное из числа
    глобальная_->определить("вещественное", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Вещественное(0.0);
            if (арг[0].этоДробное()) {
                return Значение::Вещественное(арг[0].какДробное());
            }
            return Значение::Вещественное(static_cast<double>(арг[0].вЦелое()));
        }
    )));
    
    // вещ_сложить(а, б) -> Вещественное
    глобальная_->определить("вещ_сложить", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.size() < 2) return Значение::Вещественное(0.0);
            double а = арг[0].этоДробное() ? арг[0].какДробное() : static_cast<double>(арг[0].вЦелое());
            double б = арг[1].этоДробное() ? арг[1].какДробное() : static_cast<double>(арг[1].вЦелое());
            Тринити::ТроичноеВещественное ва(а);
            Тринити::ТроичноеВещественное вб(б);
            return Значение(ва + вб);
        }
    )));
    
    // вещ_вычесть(а, б) -> Вещественное
    глобальная_->определить("вещ_вычесть", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.size() < 2) return Значение::Вещественное(0.0);
            double а = арг[0].этоДробное() ? арг[0].какДробное() : static_cast<double>(арг[0].вЦелое());
            double б = арг[1].этоДробное() ? арг[1].какДробное() : static_cast<double>(арг[1].вЦелое());
            Тринити::ТроичноеВещественное ва(а);
            Тринити::ТроичноеВещественное вб(б);
            return Значение(ва - вб);
        }
    )));
    
    // вещ_умножить(а, б) -> Вещественное
    глобальная_->определить("вещ_умножить", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.size() < 2) return Значение::Вещественное(0.0);
            double а = арг[0].этоДробное() ? арг[0].какДробное() : static_cast<double>(арг[0].вЦелое());
            double б = арг[1].этоДробное() ? арг[1].какДробное() : static_cast<double>(арг[1].вЦелое());
            Тринити::ТроичноеВещественное ва(а);
            Тринити::ТроичноеВещественное вб(б);
            return Значение(ва * вб);
        }
    )));
    
    // вещ_делить(а, б) -> Вещественное
    глобальная_->определить("вещ_делить", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.size() < 2) return Значение::Вещественное(0.0);
            double а = арг[0].этоДробное() ? арг[0].какДробное() : static_cast<double>(арг[0].вЦелое());
            double б = арг[1].этоДробное() ? арг[1].какДробное() : static_cast<double>(арг[1].вЦелое());
            if (б == 0.0) return Значение(Тринити::ТроичноеВещественное::NaN());
            Тринити::ТроичноеВещественное ва(а);
            Тринити::ТроичноеВещественное вб(б);
            return Значение(ва / вб);
        }
    )));
    
    // =========================================================================
    // Математические константы
    // =========================================================================
    
    // фи() -> Вещественное
    // Золотое сечение phi = 1.618...
    глобальная_->определить("фи", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>&) -> Значение {
            return Значение(Тринити::ТроичноеВещественное::Фи());
        }
    )));
    
    // пи() -> Вещественное
    // Число пи = 3.14159...
    глобальная_->определить("пи", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>&) -> Значение {
            return Значение(Тринити::ТроичноеВещественное::Пи());
        }
    )));
    
    // е() -> Вещественное
    // Число Эйлера e = 2.71828...
    глобальная_->определить("е", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>&) -> Значение {
            return Значение(Тринити::ТроичноеВещественное::E());
        }
    )));
    
    // триб_константа() -> Вещественное
    // Трибоначчиева константа = 1.839...
    глобальная_->определить("триб_константа", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>&) -> Значение {
            return Значение::Вещественное(Тринити::ПоследовательностьТрибоначчи::КОНСТАНТА);
        }
    )));
    
    // =========================================================================
    // Математические функции (sin, cos, sqrt, tan, exp, ln, pow, abs, floor, ceil)
    // =========================================================================
    
    // корень(x) -> Вещественное
    // Квадратный корень
    глобальная_->определить("корень", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Вещественное(0.0);
            double x = арг[0].этоДробное() ? арг[0].какДробное() : static_cast<double>(арг[0].вЦелое());
            Тринити::ТроичноеВещественное вх(x);
            return Значение(Тринити::ТроичноеВещественное::Sqrt(вх));
        }
    )));
    
    // син(x) -> Вещественное
    // Синус (аргумент в радианах)
    глобальная_->определить("син", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Вещественное(0.0);
            double x = арг[0].этоДробное() ? арг[0].какДробное() : static_cast<double>(арг[0].вЦелое());
            Тринити::ТроичноеВещественное вх(x);
            return Значение(Тринити::ТроичноеВещественное::Sin(вх));
        }
    )));
    
    // кос(x) -> Вещественное
    // Косинус (аргумент в радианах)
    глобальная_->определить("кос", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Вещественное(1.0);
            double x = арг[0].этоДробное() ? арг[0].какДробное() : static_cast<double>(арг[0].вЦелое());
            Тринити::ТроичноеВещественное вх(x);
            return Значение(Тринити::ТроичноеВещественное::Cos(вх));
        }
    )));
    
    // тан(x) -> Вещественное
    // Тангенс (аргумент в радианах)
    глобальная_->определить("тан", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Вещественное(0.0);
            double x = арг[0].этоДробное() ? арг[0].какДробное() : static_cast<double>(арг[0].вЦелое());
            Тринити::ТроичноеВещественное вх(x);
            return Значение(Тринити::ТроичноеВещественное::Tan(вх));
        }
    )));
    
    // эксп(x) -> Вещественное
    // Экспонента e^x
    глобальная_->определить("эксп", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Вещественное(1.0);
            double x = арг[0].этоДробное() ? арг[0].какДробное() : static_cast<double>(арг[0].вЦелое());
            Тринити::ТроичноеВещественное вх(x);
            return Значение(Тринити::ТроичноеВещественное::Exp(вх));
        }
    )));
    
    // лн(x) -> Вещественное
    // Натуральный логарифм ln(x)
    глобальная_->определить("лн", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение(Тринити::ТроичноеВещественное::NaN());
            double x = арг[0].этоДробное() ? арг[0].какДробное() : static_cast<double>(арг[0].вЦелое());
            Тринити::ТроичноеВещественное вх(x);
            return Значение(Тринити::ТроичноеВещественное::Ln(вх));
        }
    )));
    
    // степень(x, y) -> Вещественное
    // Возведение в степень x^y
    глобальная_->определить("степень", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.size() < 2) return Значение::Вещественное(1.0);
            double x = арг[0].этоДробное() ? арг[0].какДробное() : static_cast<double>(арг[0].вЦелое());
            double y = арг[1].этоДробное() ? арг[1].какДробное() : static_cast<double>(арг[1].вЦелое());
            Тринити::ТроичноеВещественное вх(x);
            Тринити::ТроичноеВещественное вy(y);
            return Значение(Тринити::ТроичноеВещественное::Pow(вх, вy));
        }
    )));
    
    // абс(x) -> Вещественное
    // Абсолютное значение
    глобальная_->определить("абс", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Вещественное(0.0);
            double x = арг[0].этоДробное() ? арг[0].какДробное() : static_cast<double>(арг[0].вЦелое());
            Тринити::ТроичноеВещественное вх(x);
            return Значение(Тринити::ТроичноеВещественное::Abs(вх));
        }
    )));
    
    // пол(x) -> Вещественное
    // Округление вниз (floor)
    глобальная_->определить("пол", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Вещественное(0.0);
            double x = арг[0].этоДробное() ? арг[0].какДробное() : static_cast<double>(арг[0].вЦелое());
            Тринити::ТроичноеВещественное вх(x);
            return Значение(Тринити::ТроичноеВещественное::Floor(вх));
        }
    )));
    
    // потолок(x) -> Вещественное
    // Округление вверх (ceil)
    глобальная_->определить("потолок", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (арг.empty()) return Значение::Вещественное(0.0);
            double x = арг[0].этоДробное() ? арг[0].какДробное() : static_cast<double>(арг[0].вЦелое());
            Тринити::ТроичноеВещественное вх(x);
            return Значение(Тринити::ТроичноеВещественное::Ceil(вх));
        }
    )));
    
    // =========================================================================
    // Тороидальная 3D База Данных (БД.*)
    // =========================================================================
    
    // БД_создать(слоёв, путь) -> Трит
    // Создать или открыть базу данных
    глобальная_->определить("БД_создать", Значение(ВстроеннаяФункция(
        [](Интерпретатор& интерп, const std::vector<Значение>& арг) -> Значение {
            size_t слоёв = 3;
            std::string путь = "";
            
            if (!арг.empty()) {
                слоёв = static_cast<size_t>(арг[0].вЦелое());
            }
            if (арг.size() > 1 && арг[1].этоСтрока()) {
                путь = арг[1].какСтрока();
            }
            
            глобальнаяБД = std::make_unique<Тринити::ТороидальнаяБД>(слоёв, путь);
            
            // Попробуем загрузить если файл существует
            if (!путь.empty()) {
                глобальнаяБД->загрузить();
            }
            
            интерп.вывести("БД создана: " + std::to_string(слоёв) + " слоёв");
            return Значение::Да();
        }
    )));
    
    // БД_вставить(ключ, значение) -> Строка (адрес)
    // Вставить запись в БД
    глобальная_->определить("БД_вставить", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (!глобальнаяБД) {
                return Значение::Строка("Ошибка: БД не создана");
            }
            if (арг.size() < 2) {
                return Значение::Строка("Ошибка: нужны ключ и значение");
            }
            
            std::string ключ = арг[0].вСтроку();
            int64_t значение = арг[1].вЦелое();
            
            auto адрес = глобальнаяБД->вставить(ключ, static_cast<int>(значение));
            return Значение::Строка(адрес.вСтроку());
        }
    )));
    
    // БД_найти(ключ) -> Гармония или Может
    // Найти запись по ключу
    глобальная_->определить("БД_найти", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (!глобальнаяБД) {
                return Значение::Может();
            }
            if (арг.empty()) {
                return Значение::Может();
            }
            
            std::string ключ = арг[0].вСтроку();
            auto результат = глобальнаяБД->найти(ключ);
            
            if (результат.найдено) {
                return Значение::Гармония(результат.запись.значение.вЧисло());
            }
            return Значение::Может();  // Не найдено = неопределённость
        }
    )));
    
    // БД_обновить(ключ, значение) -> Трит
    // Обновить запись
    глобальная_->определить("БД_обновить", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (!глобальнаяБД || арг.size() < 2) {
                return Значение::Нет();
            }
            
            std::string ключ = арг[0].вСтроку();
            int64_t значение = арг[1].вЦелое();
            
            bool успех = глобальнаяБД->обновить(ключ, static_cast<int>(значение));
            return успех ? Значение::Да() : Значение::Нет();
        }
    )));
    
    // БД_удалить(ключ) -> Трит
    // Удалить запись
    глобальная_->определить("БД_удалить", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (!глобальнаяБД || арг.empty()) {
                return Значение::Нет();
            }
            
            std::string ключ = арг[0].вСтроку();
            bool успех = глобальнаяБД->удалить(ключ);
            return успех ? Значение::Да() : Значение::Нет();
        }
    )));
    
    // БД_существует(ключ) -> Трит (Да/Нет/Может)
    // Проверить существование ключа
    глобальная_->определить("БД_существует", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (!глобальнаяБД || арг.empty()) {
                return Значение::Может();
            }
            
            std::string ключ = арг[0].вСтроку();
            auto статус = глобальнаяБД->существует(ключ);
            
            switch (статус) {
                case Тринити::ТроичноеЗначение::Да: return Значение::Да();
                case Тринити::ТроичноеЗначение::Нет: return Значение::Нет();
                default: return Значение::Может();
            }
        }
    )));
    
    // БД_сохранить() -> Трит
    // Сохранить БД на диск
    глобальная_->определить("БД_сохранить", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (!глобальнаяБД) {
                return Значение::Нет();
            }
            
            bool успех;
            if (!арг.empty() && арг[0].этоСтрока()) {
                успех = глобальнаяБД->сохранитьВ(арг[0].какСтрока());
            } else {
                успех = глобальнаяБД->сохранить();
            }
            return успех ? Значение::Да() : Значение::Нет();
        }
    )));
    
    // БД_загрузить(путь) -> Трит
    // Загрузить БД с диска
    глобальная_->определить("БД_загрузить", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>& арг) -> Значение {
            if (!глобальнаяБД) {
                return Значение::Нет();
            }
            
            bool успех;
            if (!арг.empty() && арг[0].этоСтрока()) {
                успех = глобальнаяБД->загрузитьИз(арг[0].какСтрока());
            } else {
                успех = глобальнаяБД->загрузить();
            }
            return успех ? Значение::Да() : Значение::Нет();
        }
    )));
    
    // БД_всего() -> Целое
    // Количество записей в БД
    глобальная_->определить("БД_всего", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>&) -> Значение {
            if (!глобальнаяБД) {
                return Значение::Целое(0);
            }
            return Значение::Целое(static_cast<int64_t>(глобальнаяБД->всегоЗаписей()));
        }
    )));
    
    // БД_слоёв() -> Целое
    // Количество слоёв в БД
    глобальная_->определить("БД_слоёв", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>&) -> Значение {
            if (!глобальнаяБД) {
                return Значение::Целое(0);
            }
            return Значение::Целое(static_cast<int64_t>(глобальнаяБД->количествоСлоёв()));
        }
    )));
    
    // БД_визуализация() -> Строка
    // Текстовая визуализация тора
    глобальная_->определить("БД_визуализация", Значение(ВстроеннаяФункция(
        [](Интерпретатор& интерп, const std::vector<Значение>&) -> Значение {
            if (!глобальнаяБД) {
                return Значение::Строка("БД не создана");
            }
            std::string виз = глобальнаяБД->визуализация();
            интерп.вывести(виз);
            return Значение::Строка(виз);
        }
    )));
    
    // БД_закрыть() -> Трит
    // Закрыть БД (сохраняет автоматически)
    глобальная_->определить("БД_закрыть", Значение(ВстроеннаяФункция(
        [](Интерпретатор&, const std::vector<Значение>&) -> Значение {
            if (глобальнаяБД) {
                глобальнаяБД->сохранить();
                глобальнаяБД.reset();
                return Значение::Да();
            }
            return Значение::Нет();
        }
    )));
}

} // namespace Троица
