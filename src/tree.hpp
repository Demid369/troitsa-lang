/**
 * @file: tree.hpp
 * @description: Древо (AST) языка "Троица"
 * @dependencies: token.hpp
 * @created: 2026-02-02
 */

#ifndef T9_TROITSA_TREE_HPP
#define T9_TROITSA_TREE_HPP

#include "troitsa/token.hpp"
#include <memory>
#include <vector>
#include <string>
#include <variant>

namespace Троица {
namespace Древо {

// Forward declarations
struct Узел;
struct Выражение;
struct Инструкция;

// Умные указатели
using УказательУзел = std::unique_ptr<Узел>;
using УказательВыражение = std::unique_ptr<Выражение>;
using УказательИнструкция = std::unique_ptr<Инструкция>;

/**
 * @brief Тип узла древа
 */
enum class ТипУзла {
    // Значения
    ЗначениеЧисло,
    ЗначениеВещественное,
    ЗначениеСтрока,
    ЗначениеСимвол,
    ЗначениеЛогика,      // Да, Нет, Может
    
    // Выражения
    Имя,                 // идентификатор
    ДвойнаяОперация,     // а + б
    ОднарнаяОперация,    // -х, НЕ у
    Вызов,               // функция(арг1, арг2)
    Доступ,              // объект.поле
    Индекс,              // массив[индекс]
    
    // Инструкции
    Пусть,               // пусть х = ...
    Присвоить,           // х = ...
    Если,                // если ... иначе
    Выбор,               // выбор { Да -> ... }
    Пока,                // пока условие { ... }
    Для,                 // для х в коллекция { ... }
    Цикл,                // цикл { ... }
    Вернуть,             // вернуть значение
    Прервать,            // прервать
    Продолжить,          // продолжить
    Блок,                // { инструкции }
    ВыражениеИнструкция, // выражение как инструкция
    
    // Объявления
    ОбъявФункция,        // функция имя() { ... }
    ОбъявТип,            // тип Имя { ... }
    ОбъявЭффект,         // эффект Имя { ... }
    ОбъявКласс,          // класс Имя { ... }
    ОбъявИмпорт,         // импорт "модуль.t9"
    
    // Литералы коллекций
    ЗначениеСловарь,     // {ключ: значение}
    ЗначениеСписок,      // [1, 2, 3]
    
    // Выражения классов
    НовыйОбъект,         // новый Класс()
    ДоступЭтот,          // этот.поле
    
    // Программа
    Программа            // корень древа
};

/**
 * @brief Базовый узел древа
 */
struct Узел {
    ТипУзла тип;
    Позиция позиция;
    
    explicit Узел(ТипУзла т, Позиция п = Позиция()) : тип(т), позиция(п) {}
    virtual ~Узел() = default;
    
    [[nodiscard]] bool это(ТипУзла т) const noexcept { return тип == т; }
};

/**
 * @brief Выражение (возвращает значение)
 */
struct Выражение : Узел {
    using Узел::Узел;
};

/**
 * @brief Инструкция (выполняет действие)
 */
struct Инструкция : Узел {
    using Узел::Узел;
};

// =============================================================================
// Значения
// =============================================================================

/**
 * @brief Числовое значение
 */
struct ЗначениеЧисло : Выражение {
    int64_t значение;
    bool троичное;  // true если это троичный литерал
    
    explicit ЗначениеЧисло(int64_t з, bool т = false, Позиция п = Позиция())
        : Выражение(ТипУзла::ЗначениеЧисло, п), значение(з), троичное(т) {}
};

/**
 * @brief Вещественное значение
 */
struct ЗначениеВещественное : Выражение {
    double значение;
    
    explicit ЗначениеВещественное(double з, Позиция п = Позиция())
        : Выражение(ТипУзла::ЗначениеВещественное, п), значение(з) {}
};

/**
 * @brief Строковое значение
 */
struct ЗначениеСтрока : Выражение {
    std::string значение;
    
    explicit ЗначениеСтрока(std::string з, Позиция п = Позиция())
        : Выражение(ТипУзла::ЗначениеСтрока, п), значение(std::move(з)) {}
};

/**
 * @brief Символьное значение
 */
struct ЗначениеСимвол : Выражение {
    char32_t значение;
    
    explicit ЗначениеСимвол(char32_t з, Позиция п = Позиция())
        : Выражение(ТипУзла::ЗначениеСимвол, п), значение(з) {}
};

/**
 * @brief Логическое значение (троичное: Да/Нет/Может)
 */
struct ЗначениеЛогика : Выражение {
    int8_t значение;  // +1 = Да, 0 = Может, -1 = Нет
    
    explicit ЗначениеЛогика(int8_t з, Позиция п = Позиция())
        : Выражение(ТипУзла::ЗначениеЛогика, п), значение(з) {}
    
    static ЗначениеЛогика Да(Позиция п = Позиция()) { return ЗначениеЛогика(+1, п); }
    static ЗначениеЛогика Нет(Позиция п = Позиция()) { return ЗначениеЛогика(-1, п); }
    static ЗначениеЛогика Может(Позиция п = Позиция()) { return ЗначениеЛогика(0, п); }
};

// =============================================================================
// Выражения
// =============================================================================

/**
 * @brief Идентификатор (имя переменной, функции и т.д.)
 */
struct Имя : Выражение {
    std::string имя;
    
    explicit Имя(std::string и, Позиция п = Позиция())
        : Выражение(ТипУзла::Имя, п), имя(std::move(и)) {}
};

/**
 * @brief Двойная операция (бинарная)
 */
struct ДвойнаяОперация : Выражение {
    ТипТокена оператор;
    УказательВыражение левое;
    УказательВыражение правое;
    
    ДвойнаяОперация(ТипТокена оп, УказательВыражение л, УказательВыражение п, Позиция поз = Позиция())
        : Выражение(ТипУзла::ДвойнаяОперация, поз)
        , оператор(оп)
        , левое(std::move(л))
        , правое(std::move(п)) {}
};

/**
 * @brief Однарная операция (унарная)
 */
struct ОднарнаяОперация : Выражение {
    ТипТокена оператор;
    УказательВыражение операнд;
    bool префикс;  // true = -x, false = x++ (если будет)
    
    ОднарнаяОперация(ТипТокена оп, УказательВыражение опер, bool преф = true, Позиция п = Позиция())
        : Выражение(ТипУзла::ОднарнаяОперация, п)
        , оператор(оп)
        , операнд(std::move(опер))
        , префикс(преф) {}
};

/**
 * @brief Вызов функции
 */
struct Вызов : Выражение {
    УказательВыражение функция;
    std::vector<УказательВыражение> аргументы;
    
    Вызов(УказательВыражение ф, std::vector<УказательВыражение> арг, Позиция п = Позиция())
        : Выражение(ТипУзла::Вызов, п)
        , функция(std::move(ф))
        , аргументы(std::move(арг)) {}
};

/**
 * @brief Доступ к полю (объект.поле)
 */
struct Доступ : Выражение {
    УказательВыражение объект;
    std::string поле;
    
    Доступ(УказательВыражение об, std::string п, Позиция поз = Позиция())
        : Выражение(ТипУзла::Доступ, поз)
        , объект(std::move(об))
        , поле(std::move(п)) {}
};

/**
 * @brief Индексация (массив[индекс])
 */
struct Индекс : Выражение {
    УказательВыражение объект;
    УказательВыражение индекс;
    
    Индекс(УказательВыражение об, УказательВыражение инд, Позиция п = Позиция())
        : Выражение(ТипУзла::Индекс, п)
        , объект(std::move(об))
        , индекс(std::move(инд)) {}
};

// =============================================================================
// Инструкции
// =============================================================================

/**
 * @brief Объявление переменной (пусть х = ...)
 */
struct Пусть : Инструкция {
    std::string имя;
    std::string тип;  // Опционально: пусть х: Гармония = ...
    УказательВыражение значение;
    bool изменяемый;  // изм х = ...
    
    Пусть(std::string и, УказательВыражение з, bool изм = false, Позиция п = Позиция())
        : Инструкция(ТипУзла::Пусть, п)
        , имя(std::move(и))
        , значение(std::move(з))
        , изменяемый(изм) {}
};

/**
 * @brief Присваивание (х = ...)
 */
struct Присвоить : Инструкция {
    УказательВыражение цель;
    УказательВыражение значение;
    ТипТокена оператор;  // =, +=, -=
    
    Присвоить(УказательВыражение ц, УказательВыражение з, ТипТокена оп = ТипТокена::ОпПрисвоить, Позиция п = Позиция())
        : Инструкция(ТипУзла::Присвоить, п)
        , цель(std::move(ц))
        , значение(std::move(з))
        , оператор(оп) {}
};

/**
 * @brief Условие (если ... иначе)
 */
struct Если : Инструкция {
    УказательВыражение условие;
    УказательИнструкция тогда;
    УказательИнструкция иначе;  // может быть nullptr
    
    Если(УказательВыражение усл, УказательИнструкция тог, УказательИнструкция ин = nullptr, Позиция п = Позиция())
        : Инструкция(ТипУзла::Если, п)
        , условие(std::move(усл))
        , тогда(std::move(тог))
        , иначе(std::move(ин)) {}
};

/**
 * @brief Ветка выбора
 */
struct ВеткаВыбора {
    УказательВыражение образец;  // Да, Нет, Может, или выражение
    УказательИнструкция тело;
};

/**
 * @brief Троичный выбор (выбор значение { Да -> ... })
 */
struct Выбор : Инструкция {
    УказательВыражение значение;
    std::vector<ВеткаВыбора> ветки;
    
    Выбор(УказательВыражение з, std::vector<ВеткаВыбора> в, Позиция п = Позиция())
        : Инструкция(ТипУзла::Выбор, п)
        , значение(std::move(з))
        , ветки(std::move(в)) {}
};

/**
 * @brief Цикл пока (пока условие { ... })
 */
struct Пока : Инструкция {
    УказательВыражение условие;
    УказательИнструкция тело;
    
    Пока(УказательВыражение усл, УказательИнструкция т, Позиция п = Позиция())
        : Инструкция(ТипУзла::Пока, п)
        , условие(std::move(усл))
        , тело(std::move(т)) {}
};

/**
 * @brief Цикл для (для х в коллекция { ... })
 */
struct Для : Инструкция {
    std::string переменная;
    УказательВыражение коллекция;
    УказательИнструкция тело;
    
    Для(std::string пер, УказательВыражение кол, УказательИнструкция т, Позиция п = Позиция())
        : Инструкция(ТипУзла::Для, п)
        , переменная(std::move(пер))
        , коллекция(std::move(кол))
        , тело(std::move(т)) {}
};

/**
 * @brief Бесконечный цикл (цикл { ... })
 */
struct Цикл : Инструкция {
    УказательИнструкция тело;
    
    explicit Цикл(УказательИнструкция т, Позиция п = Позиция())
        : Инструкция(ТипУзла::Цикл, п)
        , тело(std::move(т)) {}
};

/**
 * @brief Возврат из функции
 */
struct Вернуть : Инструкция {
    УказательВыражение значение;  // может быть nullptr
    
    explicit Вернуть(УказательВыражение з = nullptr, Позиция п = Позиция())
        : Инструкция(ТипУзла::Вернуть, п)
        , значение(std::move(з)) {}
};

/**
 * @brief Прервать цикл
 */
struct Прервать : Инструкция {
    explicit Прервать(Позиция п = Позиция())
        : Инструкция(ТипУзла::Прервать, п) {}
};

/**
 * @brief Продолжить цикл
 */
struct Продолжить : Инструкция {
    explicit Продолжить(Позиция п = Позиция())
        : Инструкция(ТипУзла::Продолжить, п) {}
};

/**
 * @brief Блок инструкций
 */
struct Блок : Инструкция {
    std::vector<УказательИнструкция> инструкции;
    
    explicit Блок(std::vector<УказательИнструкция> инстр = {}, Позиция п = Позиция())
        : Инструкция(ТипУзла::Блок, п)
        , инструкции(std::move(инстр)) {}
};

/**
 * @brief Выражение как инструкция
 */
struct ВыражениеИнструкция : Инструкция {
    УказательВыражение выражение;
    
    explicit ВыражениеИнструкция(УказательВыражение выр, Позиция п = Позиция())
        : Инструкция(ТипУзла::ВыражениеИнструкция, п)
        , выражение(std::move(выр)) {}
};

// =============================================================================
// Объявления
// =============================================================================

/**
 * @brief Параметр функции
 */
struct Параметр {
    std::string имя;
    std::string тип;
    bool владеть;  // владеть Т — передача владения
    
    Параметр(std::string и, std::string т, bool в = false)
        : имя(std::move(и)), тип(std::move(т)), владеть(в) {}
};

/**
 * @brief Объявление функции
 */
struct ОбъявФункция : Инструкция {
    std::string имя;
    std::vector<Параметр> параметры;
    std::string возвращаемыйТип;
    std::vector<std::string> эффекты;  // с Ввод, Вывод
    УказательИнструкция тело;
    
    ОбъявФункция(std::string и, std::vector<Параметр> пар, std::string возвр, 
                 УказательИнструкция т, Позиция п = Позиция())
        : Инструкция(ТипУзла::ОбъявФункция, п)
        , имя(std::move(и))
        , параметры(std::move(пар))
        , возвращаемыйТип(std::move(возвр))
        , тело(std::move(т)) {}
};

// =============================================================================
// Классы
// =============================================================================

/**
 * @brief Поле класса
 */
struct ПолеКласса {
    std::string имя;
    std::string тип;
    УказательВыражение значениеПоУмолчанию;
    bool частный;
    bool статический;
    
    ПолеКласса(std::string и, std::string т = "", bool ч = false, bool с = false)
        : имя(std::move(и)), тип(std::move(т)), частный(ч), статический(с) {}
};

/**
 * @brief Метод класса
 */
struct МетодКласса {
    std::string имя;
    std::vector<Параметр> параметры;
    std::string возвращаемыйТип;
    УказательИнструкция тело;
    bool частный;
    bool статический;
    
    МетодКласса(std::string и, std::vector<Параметр> пар, УказательИнструкция т,
                bool ч = false, bool с = false)
        : имя(std::move(и)), параметры(std::move(пар)), тело(std::move(т))
        , частный(ч), статический(с) {}
};

/**
 * @brief Объявление класса
 */
struct ОбъявКласс : Инструкция {
    std::string имя;
    std::string родитель;  // наследует от
    std::vector<ПолеКласса> поля;
    std::vector<МетодКласса> методы;
    
    ОбъявКласс(std::string и, Позиция п = Позиция())
        : Инструкция(ТипУзла::ОбъявКласс, п)
        , имя(std::move(и)) {}
};

/**
 * @brief Создание нового объекта (новый Класс())
 */
struct НовыйОбъект : Выражение {
    std::string класс;
    std::vector<УказательВыражение> аргументы;
    
    НовыйОбъект(std::string к, std::vector<УказательВыражение> арг, Позиция п = Позиция())
        : Выражение(ТипУзла::НовыйОбъект, п)
        , класс(std::move(к))
        , аргументы(std::move(арг)) {}
};

// =============================================================================
// Словари
// =============================================================================

/**
 * @brief Пара ключ-значение для словаря
 */
struct ПараСловаря {
    УказательВыражение ключ;
    УказательВыражение значение;
};

/**
 * @brief Литерал словаря {ключ: значение}
 */
struct ЗначениеСловарь : Выражение {
    std::vector<ПараСловаря> пары;
    
    explicit ЗначениеСловарь(std::vector<ПараСловаря> п = {}, Позиция поз = Позиция())
        : Выражение(ТипУзла::ЗначениеСловарь, поз)
        , пары(std::move(п)) {}
};

/**
 * @brief Литерал списка [1, 2, 3]
 */
struct ЗначениеСписок : Выражение {
    std::vector<УказательВыражение> элементы;
    
    explicit ЗначениеСписок(std::vector<УказательВыражение> эл = {}, Позиция п = Позиция())
        : Выражение(ТипУзла::ЗначениеСписок, п)
        , элементы(std::move(эл)) {}
};

// =============================================================================
// Модули
// =============================================================================

/**
 * @brief Импорт модуля
 */
struct ОбъявИмпорт : Инструкция {
    std::string путь;           // "модуль.t9"
    std::string псевдоним;      // как Имя
    std::vector<std::string> имена;  // импорт {Функция1, Функция2} из "модуль.t9"
    bool всё;                   // импорт * из "модуль.t9"
    
    ОбъявИмпорт(std::string п, Позиция поз = Позиция())
        : Инструкция(ТипУзла::ОбъявИмпорт, поз)
        , путь(std::move(п))
        , всё(false) {}
};

// =============================================================================
// Программа
// =============================================================================

/**
 * @brief Программа (корень древа)
 */
struct Программа : Узел {
    std::vector<УказательИнструкция> объявления;
    
    explicit Программа(std::vector<УказательИнструкция> об = {}, Позиция п = Позиция())
        : Узел(ТипУзла::Программа, п)
        , объявления(std::move(об)) {}
};

// =============================================================================
// Вспомогательные функции
// =============================================================================

/**
 * @brief Получить имя типа узла
 */
[[nodiscard]] std::string имяТипаУзла(ТипУзла тип);

} // namespace Древо
} // namespace Троица

#endif // T9_TROITSA_TREE_HPP
