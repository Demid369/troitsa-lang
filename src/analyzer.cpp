/**
 * @file: analyzer.cpp
 * @description: Реализация Анализатора языка "Троица"
 * @dependencies: analyzer.hpp
 * @created: 2026-02-02
 */

#include "troitsa/analyzer.hpp"

namespace Троица {

// === Конструктор ===

Анализатор::Анализатор(Лексер& лексер)
    : лексер_(лексер)
{
    продвинуться(); // Загружаем первый токен
}

// === Основные методы ===

std::unique_ptr<Древо::Программа> Анализатор::анализировать() {
    auto программа = std::make_unique<Древо::Программа>();
    
    while (!проверить(ТипТокена::КонецФайла)) {
        auto инстр = инструкция();
        if (инстр) {
            программа->объявления.push_back(std::move(инстр));
        } else {
            // Пропускаем ошибочный токен
            продвинуться();
        }
    }
    
    return программа;
}

Древо::УказательВыражение Анализатор::выражение() {
    return выражениеИли();
}

Древо::УказательИнструкция Анализатор::инструкция() {
    // Объявления
    if (проверить(ТипТокена::КлючФункция)) {
        return объявлениеФункция();
    }
    
    // Инструкции
    if (проверить(ТипТокена::КлючПусть) || проверить(ТипТокена::КлючИзменяемый)) {
        return инструкцияПусть();
    }
    
    if (проверить(ТипТокена::КлючЕсли)) {
        return инструкцияЕсли();
    }
    
    if (проверить(ТипТокена::КлючВыбор)) {
        return инструкцияВыбор();
    }
    
    if (проверить(ТипТокена::КлючПока)) {
        return инструкцияПока();
    }
    
    if (проверить(ТипТокена::КлючДля)) {
        return инструкцияДля();
    }
    
    if (проверить(ТипТокена::КлючЦикл)) {
        return инструкцияЦикл();
    }
    
    if (проверить(ТипТокена::КлючВернуть)) {
        return инструкцияВернуть();
    }
    
    if (проверить(ТипТокена::КлючПрервать)) {
        auto поз = текущий_.позиция;
        продвинуться();
        return std::make_unique<Древо::Прервать>(поз);
    }
    
    if (проверить(ТипТокена::КлючПродолжить)) {
        auto поз = текущий_.позиция;
        продвинуться();
        return std::make_unique<Древо::Продолжить>(поз);
    }
    
    if (проверить(ТипТокена::СкобкаФигурнаяОткр)) {
        return инструкцияБлок();
    }
    
    // Выражение как инструкция (включая присваивание)
    auto поз = текущий_.позиция;
    auto выр = выражение();
    
    if (!выр) {
        return nullptr;
    }
    
    // Проверяем присваивание
    if (проверить(ТипТокена::ОпПрисвоить) || 
        проверить(ТипТокена::ОпПлюсПрисвоить) || 
        проверить(ТипТокена::ОпМинусПрисвоить)) {
        
        auto оп = текущий_.тип;
        продвинуться();
        auto значение = выражение();
        
        return std::make_unique<Древо::Присвоить>(
            std::move(выр), std::move(значение), оп, поз);
    }
    
    return std::make_unique<Древо::ВыражениеИнструкция>(std::move(выр), поз);
}

// === Работа с токенами ===

void Анализатор::продвинуться() {
    текущий_ = лексер_.следующийТокен();
}

bool Анализатор::проверить(ТипТокена тип) const noexcept {
    return текущий_.тип == тип;
}

bool Анализатор::совпадает(ТипТокена тип) {
    if (проверить(тип)) {
        продвинуться();
        return true;
    }
    return false;
}

bool Анализатор::ожидать(ТипТокена тип, const std::string& сообщение) {
    if (проверить(тип)) {
        продвинуться();
        return true;
    }
    ошибка(сообщение);
    return false;
}

void Анализатор::ошибка(const std::string& сообщение) {
    ошибки_.emplace_back(сообщение, текущий_.позиция);
}

// === Выражения ===

Древо::УказательВыражение Анализатор::выражениеИли() {
    auto левое = выражениеИ();
    
    while (проверить(ТипТокена::ОпИли)) {
        auto поз = текущий_.позиция;
        auto оп = текущий_.тип;
        продвинуться();
        auto правое = выражениеИ();
        левое = std::make_unique<Древо::ДвойнаяОперация>(
            оп, std::move(левое), std::move(правое), поз);
    }
    
    return левое;
}

Древо::УказательВыражение Анализатор::выражениеИ() {
    auto левое = выражениеКонсенсус();
    
    while (проверить(ТипТокена::ОпИ)) {
        auto поз = текущий_.позиция;
        auto оп = текущий_.тип;
        продвинуться();
        auto правое = выражениеКонсенсус();
        левое = std::make_unique<Древо::ДвойнаяОперация>(
            оп, std::move(левое), std::move(правое), поз);
    }
    
    return левое;
}

Древо::УказательВыражение Анализатор::выражениеКонсенсус() {
    auto левое = выражениеРавенство();
    
    while (проверить(ТипТокена::ОпКонсенсус)) {
        auto поз = текущий_.позиция;
        auto оп = текущий_.тип;
        продвинуться();
        auto правое = выражениеРавенство();
        левое = std::make_unique<Древо::ДвойнаяОперация>(
            оп, std::move(левое), std::move(правое), поз);
    }
    
    return левое;
}

Древо::УказательВыражение Анализатор::выражениеРавенство() {
    auto левое = выражениеСравнение();
    
    while (проверить(ТипТокена::ОпРавно) || проверить(ТипТокена::ОпНеРавно)) {
        auto поз = текущий_.позиция;
        auto оп = текущий_.тип;
        продвинуться();
        auto правое = выражениеСравнение();
        левое = std::make_unique<Древо::ДвойнаяОперация>(
            оп, std::move(левое), std::move(правое), поз);
    }
    
    return левое;
}

Древо::УказательВыражение Анализатор::выражениеСравнение() {
    auto левое = выражениеСложение();
    
    while (проверить(ТипТокена::ОпМеньше) || проверить(ТипТокена::ОпБольше) ||
           проверить(ТипТокена::ОпМеньшеРавно) || проверить(ТипТокена::ОпБольшеРавно)) {
        auto поз = текущий_.позиция;
        auto оп = текущий_.тип;
        продвинуться();
        auto правое = выражениеСложение();
        левое = std::make_unique<Древо::ДвойнаяОперация>(
            оп, std::move(левое), std::move(правое), поз);
    }
    
    return левое;
}

Древо::УказательВыражение Анализатор::выражениеСложение() {
    auto левое = выражениеУмножение();
    
    while (проверить(ТипТокена::ОпПлюс) || проверить(ТипТокена::ОпМинус)) {
        auto поз = текущий_.позиция;
        auto оп = текущий_.тип;
        продвинуться();
        auto правое = выражениеУмножение();
        левое = std::make_unique<Древо::ДвойнаяОперация>(
            оп, std::move(левое), std::move(правое), поз);
    }
    
    return левое;
}

Древо::УказательВыражение Анализатор::выражениеУмножение() {
    auto левое = выражениеУнарное();
    
    while (проверить(ТипТокена::ОпУмножить) || проверить(ТипТокена::ОпДелить) ||
           проверить(ТипТокена::ОпОстаток)) {
        auto поз = текущий_.позиция;
        auto оп = текущий_.тип;
        продвинуться();
        auto правое = выражениеУнарное();
        левое = std::make_unique<Древо::ДвойнаяОперация>(
            оп, std::move(левое), std::move(правое), поз);
    }
    
    return левое;
}

Древо::УказательВыражение Анализатор::выражениеУнарное() {
    if (проверить(ТипТокена::ОпМинус) || проверить(ТипТокена::ОпНе)) {
        auto поз = текущий_.позиция;
        auto оп = текущий_.тип;
        продвинуться();
        auto операнд = выражениеУнарное();
        return std::make_unique<Древо::ОднарнаяОперация>(оп, std::move(операнд), true, поз);
    }
    
    return выражениеВызов();
}

Древо::УказательВыражение Анализатор::выражениеВызов() {
    auto выр = выражениеПервичное();
    
    while (true) {
        if (проверить(ТипТокена::СкобкаКруглаяОткр)) {
            // Вызов функции
            auto поз = текущий_.позиция;
            auto аргументы = списокАргументов();
            выр = std::make_unique<Древо::Вызов>(std::move(выр), std::move(аргументы), поз);
        } else if (проверить(ТипТокена::Точка)) {
            // Доступ к полю
            auto поз = текущий_.позиция;
            продвинуться();
            if (!проверить(ТипТокена::Идентификатор)) {
                ошибка("Ожидалось имя поля после '.'");
                break;
            }
            auto поле = текущий_.какСтрока();
            продвинуться();
            выр = std::make_unique<Древо::Доступ>(std::move(выр), поле, поз);
        } else if (проверить(ТипТокена::СкобкаКвадратнаяОткр)) {
            // Индексация
            auto поз = текущий_.позиция;
            продвинуться();
            auto индекс = выражение();
            ожидать(ТипТокена::СкобкаКвадратнаяЗакр, "Ожидалась ']'");
            выр = std::make_unique<Древо::Индекс>(std::move(выр), std::move(индекс), поз);
        } else {
            break;
        }
    }
    
    return выр;
}

Древо::УказательВыражение Анализатор::выражениеПервичное() {
    auto поз = текущий_.позиция;
    
    // Числа
    if (проверить(ТипТокена::ЧислоЦелое)) {
        auto значение = текущий_.какЦелое();
        продвинуться();
        return std::make_unique<Древо::ЗначениеЧисло>(значение, false, поз);
    }
    
    if (проверить(ТипТокена::ЧислоВещественное)) {
        auto значение = текущий_.какВещественное();
        продвинуться();
        return std::make_unique<Древо::ЗначениеВещественное>(значение, поз);
    }
    
    if (проверить(ТипТокена::ЧислоТроичное)) {
        auto значение = текущий_.какЦелое();
        продвинуться();
        return std::make_unique<Древо::ЗначениеЧисло>(значение, true, поз);
    }
    
    // Строки
    if (проверить(ТипТокена::Строка)) {
        auto значение = текущий_.какСтрока();
        продвинуться();
        return std::make_unique<Древо::ЗначениеСтрока>(значение, поз);
    }
    
    // Символы
    if (проверить(ТипТокена::Символ)) {
        auto значение = текущий_.какСимвол();
        продвинуться();
        return std::make_unique<Древо::ЗначениеСимвол>(значение, поз);
    }
    
    // Троичные значения
    if (проверить(ТипТокена::КлючДа)) {
        продвинуться();
        return std::make_unique<Древо::ЗначениеЛогика>(+1, поз);
    }
    
    if (проверить(ТипТокена::КлючНет)) {
        продвинуться();
        return std::make_unique<Древо::ЗначениеЛогика>(-1, поз);
    }
    
    if (проверить(ТипТокена::КлючМожет)) {
        продвинуться();
        return std::make_unique<Древо::ЗначениеЛогика>(0, поз);
    }
    
    // Идентификатор
    if (проверить(ТипТокена::Идентификатор)) {
        auto имя = текущий_.какСтрока();
        продвинуться();
        return std::make_unique<Древо::Имя>(имя, поз);
    }
    
    // Скобки
    if (совпадает(ТипТокена::СкобкаКруглаяОткр)) {
        auto выр = выражение();
        ожидать(ТипТокена::СкобкаКруглаяЗакр, "Ожидалась ')'");
        return выр;
    }
    
    ошибка("Ожидалось выражение");
    return nullptr;
}

// === Инструкции ===

Древо::УказательИнструкция Анализатор::инструкцияПусть() {
    auto поз = текущий_.позиция;
    bool изменяемый = проверить(ТипТокена::КлючИзменяемый);
    
    if (изменяемый) {
        продвинуться(); // изм
    } else {
        продвинуться(); // пусть
    }
    
    if (!проверить(ТипТокена::Идентификатор)) {
        ошибка("Ожидалось имя переменной");
        return nullptr;
    }
    
    auto имя = текущий_.какСтрока();
    продвинуться();
    
    // Опциональная аннотация типа
    std::string тип;
    if (совпадает(ТипТокена::Двоеточие)) {
        тип = типАннотация();
    }
    
    // Инициализатор
    Древо::УказательВыражение значение;
    if (совпадает(ТипТокена::ОпПрисвоить)) {
        значение = выражение();
    }
    
    auto результат = std::make_unique<Древо::Пусть>(имя, std::move(значение), изменяемый, поз);
    результат->тип = тип;
    return результат;
}

Древо::УказательИнструкция Анализатор::инструкцияЕсли() {
    auto поз = текущий_.позиция;
    продвинуться(); // если
    
    auto условие = выражение();
    auto тогда = инструкцияБлок();
    
    Древо::УказательИнструкция иначе;
    if (совпадает(ТипТокена::КлючИначе)) {
        if (проверить(ТипТокена::КлючЕсли)) {
            иначе = инструкцияЕсли(); // else if
        } else {
            иначе = инструкцияБлок();
        }
    }
    
    return std::make_unique<Древо::Если>(
        std::move(условие), std::move(тогда), std::move(иначе), поз);
}

Древо::УказательИнструкция Анализатор::инструкцияВыбор() {
    auto поз = текущий_.позиция;
    продвинуться(); // выбор
    
    auto значение = выражение();
    
    ожидать(ТипТокена::СкобкаФигурнаяОткр, "Ожидалась '{'");
    
    std::vector<Древо::ВеткаВыбора> ветки;
    
    while (!проверить(ТипТокена::СкобкаФигурнаяЗакр) && !проверить(ТипТокена::КонецФайла)) {
        Древо::ВеткаВыбора ветка;
        ветка.образец = выражение();
        
        ожидать(ТипТокена::Стрелка, "Ожидалась '->'");
        
        // Тело ветки может быть блоком или одним выражением
        if (проверить(ТипТокена::СкобкаФигурнаяОткр)) {
            ветка.тело = инструкцияБлок();
        } else {
            auto выр = выражение();
            ветка.тело = std::make_unique<Древо::ВыражениеИнструкция>(std::move(выр));
        }
        
        ветки.push_back(std::move(ветка));
    }
    
    ожидать(ТипТокена::СкобкаФигурнаяЗакр, "Ожидалась '}'");
    
    return std::make_unique<Древо::Выбор>(std::move(значение), std::move(ветки), поз);
}

Древо::УказательИнструкция Анализатор::инструкцияПока() {
    auto поз = текущий_.позиция;
    продвинуться(); // пока
    
    auto условие = выражение();
    auto тело = инструкцияБлок();
    
    return std::make_unique<Древо::Пока>(std::move(условие), std::move(тело), поз);
}

Древо::УказательИнструкция Анализатор::инструкцияДля() {
    auto поз = текущий_.позиция;
    продвинуться(); // для
    
    if (!проверить(ТипТокена::Идентификатор)) {
        ошибка("Ожидалось имя переменной");
        return nullptr;
    }
    
    auto переменная = текущий_.какСтрока();
    продвинуться();
    
    ожидать(ТипТокена::КлючВ, "Ожидалось 'в'");
    
    auto коллекция = выражение();
    auto тело = инструкцияБлок();
    
    return std::make_unique<Древо::Для>(переменная, std::move(коллекция), std::move(тело), поз);
}

Древо::УказательИнструкция Анализатор::инструкцияЦикл() {
    auto поз = текущий_.позиция;
    продвинуться(); // цикл
    
    auto тело = инструкцияБлок();
    
    return std::make_unique<Древо::Цикл>(std::move(тело), поз);
}

Древо::УказательИнструкция Анализатор::инструкцияВернуть() {
    auto поз = текущий_.позиция;
    продвинуться(); // вернуть
    
    Древо::УказательВыражение значение;
    
    // Проверяем, есть ли выражение после вернуть
    if (!проверить(ТипТокена::СкобкаФигурнаяЗакр) && 
        !проверить(ТипТокена::КонецФайла)) {
        значение = выражение();
    }
    
    return std::make_unique<Древо::Вернуть>(std::move(значение), поз);
}

Древо::УказательИнструкция Анализатор::инструкцияБлок() {
    auto поз = текущий_.позиция;
    
    ожидать(ТипТокена::СкобкаФигурнаяОткр, "Ожидалась '{'");
    
    std::vector<Древо::УказательИнструкция> инструкции;
    
    while (!проверить(ТипТокена::СкобкаФигурнаяЗакр) && !проверить(ТипТокена::КонецФайла)) {
        auto инстр = инструкция();
        if (инстр) {
            инструкции.push_back(std::move(инстр));
        } else {
            продвинуться(); // Пропускаем ошибочный токен
        }
    }
    
    ожидать(ТипТокена::СкобкаФигурнаяЗакр, "Ожидалась '}'");
    
    return std::make_unique<Древо::Блок>(std::move(инструкции), поз);
}

// === Объявления ===

Древо::УказательИнструкция Анализатор::объявлениеФункция() {
    auto поз = текущий_.позиция;
    продвинуться(); // функция
    
    if (!проверить(ТипТокена::Идентификатор)) {
        ошибка("Ожидалось имя функции");
        return nullptr;
    }
    
    auto имя = текущий_.какСтрока();
    продвинуться();
    
    auto параметры = параметрыФункции();
    
    // Возвращаемый тип
    std::string возвращаемыйТип;
    if (совпадает(ТипТокена::Стрелка)) {
        возвращаемыйТип = типАннотация();
    }
    
    // Эффекты
    std::vector<std::string> эффекты;
    if (совпадает(ТипТокена::КлючС)) {
        do {
            if (проверить(ТипТокена::Идентификатор)) {
                эффекты.push_back(текущий_.какСтрока());
                продвинуться();
            }
        } while (совпадает(ТипТокена::Запятая));
    }
    
    auto тело = инструкцияБлок();
    
    auto функция = std::make_unique<Древо::ОбъявФункция>(
        имя, std::move(параметры), возвращаемыйТип, std::move(тело), поз);
    функция->эффекты = std::move(эффекты);
    
    return функция;
}

// === Вспомогательные ===

std::vector<Древо::УказательВыражение> Анализатор::списокАргументов() {
    std::vector<Древо::УказательВыражение> аргументы;
    
    ожидать(ТипТокена::СкобкаКруглаяОткр, "Ожидалась '('");
    
    if (!проверить(ТипТокена::СкобкаКруглаяЗакр)) {
        do {
            аргументы.push_back(выражение());
        } while (совпадает(ТипТокена::Запятая));
    }
    
    ожидать(ТипТокена::СкобкаКруглаяЗакр, "Ожидалась ')'");
    
    return аргументы;
}

std::vector<Древо::Параметр> Анализатор::параметрыФункции() {
    std::vector<Древо::Параметр> параметры;
    
    ожидать(ТипТокена::СкобкаКруглаяОткр, "Ожидалась '('");
    
    if (!проверить(ТипТокена::СкобкаКруглаяЗакр)) {
        do {
            bool владеть = совпадает(ТипТокена::КлючВладеть);
            
            if (!проверить(ТипТокена::Идентификатор)) {
                ошибка("Ожидалось имя параметра");
                break;
            }
            
            auto имя = текущий_.какСтрока();
            продвинуться();
            
            std::string тип;
            if (совпадает(ТипТокена::Двоеточие)) {
                тип = типАннотация();
            }
            
            параметры.emplace_back(имя, тип, владеть);
        } while (совпадает(ТипТокена::Запятая));
    }
    
    ожидать(ТипТокена::СкобкаКруглаяЗакр, "Ожидалась ')'");
    
    return параметры;
}

std::string Анализатор::типАннотация() {
    std::string тип;
    
    // Простой тип или параметризованный (Список(Гармония))
    if (проверить(ТипТокена::Идентификатор) || этоКлючевоеСлово(текущий_.тип)) {
        тип = текущий_.текст;
        продвинуться();
        
        // Параметры типа
        if (совпадает(ТипТокена::СкобкаКруглаяОткр)) {
            тип += "(";
            тип += типАннотация();
            while (совпадает(ТипТокена::Запятая)) {
                тип += ", ";
                тип += типАннотация();
            }
            ожидать(ТипТокена::СкобкаКруглаяЗакр, "Ожидалась ')'");
            тип += ")";
        }
    }
    
    return тип;
}

} // namespace Троица
