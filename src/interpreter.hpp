/**
 * @file: interpreter.hpp
 * @description: Интерпретатор языка "Троица"
 * @dependencies: tree.hpp, semantics.hpp
 * @created: 2026-02-02
 */

#ifndef T9_TROITSA_INTERPRETER_HPP
#define T9_TROITSA_INTERPRETER_HPP

#include "troitsa/tree.hpp"
#include "troitsa/semantics.hpp"
#include "trinity/tribonacci.hpp"
#include "trinity/float.hpp"
#include <string>
#include <vector>
#include <map>
#include <memory>
#include <variant>
#include <functional>
#include <stdexcept>

namespace Троица {

// =============================================================================
// Значения времени выполнения
// =============================================================================

// Forward declaration
class Интерпретатор;

/**
 * @brief Троичное значение (Трит)
 */
struct ЗначениеТрит {
    int8_t значение;  // -1, 0, +1
    
    ЗначениеТрит() : значение(0) {}
    explicit ЗначениеТрит(int8_t з) : значение(з) {
        if (з < -1) значение = -1;
        if (з > 1) значение = 1;
    }
    
    [[nodiscard]] bool да() const noexcept { return значение == 1; }
    [[nodiscard]] bool нет() const noexcept { return значение == -1; }
    [[nodiscard]] bool может() const noexcept { return значение == 0; }
    
    // Троичная логика MIN/MAX
    [[nodiscard]] ЗначениеТрит и(const ЗначениеТрит& другой) const {
        return ЗначениеТрит(std::min(значение, другой.значение));
    }
    
    [[nodiscard]] ЗначениеТрит или(const ЗначениеТрит& другой) const {
        return ЗначениеТрит(std::max(значение, другой.значение));
    }
    
    [[nodiscard]] ЗначениеТрит не() const {
        return ЗначениеТрит(static_cast<int8_t>(-значение));
    }
    
    [[nodiscard]] ЗначениеТрит консенсус(const ЗначениеТрит& другой) const {
        return ЗначениеТрит(значение == другой.значение ? значение : 0);
    }
};

/**
 * @brief Гармония (9 тритов)
 */
struct ЗначениеГармония {
    std::array<int8_t, 9> триты;
    
    ЗначениеГармония() { триты.fill(0); }
    
    explicit ЗначениеГармония(int64_t число) {
        триты.fill(0);
        bool отрицательное = число < 0;
        if (отрицательное) число = -число;
        
        for (int i = 0; i < 9 && число != 0; ++i) {
            int остаток = число % 3;
            число /= 3;
            if (остаток == 2) {
                остаток = -1;
                число++;
            }
            триты[i] = static_cast<int8_t>(отрицательное ? -остаток : остаток);
        }
    }
    
    [[nodiscard]] int64_t вЧисло() const {
        int64_t результат = 0;
        int64_t степень = 1;
        for (int i = 0; i < 9; ++i) {
            результат += триты[i] * степень;
            степень *= 3;
        }
        return результат;
    }
    
    [[nodiscard]] ЗначениеТрит трит(size_t индекс) const {
        if (индекс >= 9) return ЗначениеТрит(0);
        return ЗначениеТрит(триты[индекс]);
    }
};

/**
 * @brief Встроенная функция
 */
class Значение;
using ВстроеннаяФункция = std::function<Значение(Интерпретатор&, const std::vector<Значение>&)>;

/**
 * @brief Пользовательская функция
 */
struct ПользовательскаяФункция {
    std::vector<std::string> параметры;
    Древо::Инструкция* тело;
    std::shared_ptr<class СредаВыполнения> замыкание;
};

// Forward declarations для классов и словарей
struct ОпределениеКласса;
struct ЭкземплярКласса;
struct ЗначениеСловарь;

/**
 * @brief Значение времени выполнения
 */
class Значение {
public:
    using Вариант = std::variant<
        std::monostate,           // Пусто (void)
        ЗначениеТрит,             // Трит
        ЗначениеГармония,         // Гармония
        int64_t,                  // Целое
        double,                   // Дробное
        std::string,              // Строка
        char32_t,                 // Символ
        bool,                     // Логика (для совместимости)
        std::vector<Значение>,    // Список
        ВстроеннаяФункция,        // Встроенная функция
        std::shared_ptr<ПользовательскаяФункция>,  // Пользовательская функция
        Тринити::Трибоначчи,      // Трибоначчи (27 тритов)
        Тринити::ТроичноеВещественное,  // Вещественное (27 тритов)
        std::shared_ptr<ЭкземплярКласса>,  // Объект класса
        std::shared_ptr<ЗначениеСловарь>   // Словарь
    >;
    
    Значение() : данные_(std::monostate{}) {}
    
    // Конструкторы для разных типов
    explicit Значение(ЗначениеТрит т) : данные_(т) {}
    explicit Значение(ЗначениеГармония г) : данные_(г) {}
    explicit Значение(int64_t ц) : данные_(ц) {}
    explicit Значение(int ц) : данные_(static_cast<int64_t>(ц)) {}
    explicit Значение(double д) : данные_(д) {}
    explicit Значение(const std::string& с) : данные_(с) {}
    explicit Значение(std::string&& с) : данные_(std::move(с)) {}
    explicit Значение(const char* с) : данные_(std::string(с)) {}
    explicit Значение(char32_t с) : данные_(с) {}
    explicit Значение(bool л) : данные_(л) {}
    explicit Значение(std::vector<Значение> сп) : данные_(std::move(сп)) {}
    explicit Значение(ВстроеннаяФункция ф) : данные_(std::move(ф)) {}
    explicit Значение(std::shared_ptr<ПользовательскаяФункция> ф) : данные_(std::move(ф)) {}
    explicit Значение(Тринити::Трибоначчи т) : данные_(std::move(т)) {}
    explicit Значение(Тринити::ТроичноеВещественное в) : данные_(std::move(в)) {}
    explicit Значение(std::shared_ptr<ЭкземплярКласса> об) : данные_(std::move(об)) {}
    explicit Значение(std::shared_ptr<ЗначениеСловарь> сл) : данные_(std::move(сл)) {}
    
    // Статические конструкторы
    static Значение Пусто() { return Значение(); }
    static Значение Да() { return Значение(ЗначениеТрит(1)); }
    static Значение Нет() { return Значение(ЗначениеТрит(-1)); }
    static Значение Может() { return Значение(ЗначениеТрит(0)); }
    static Значение Трит(int8_t з) { return Значение(ЗначениеТрит(з)); }
    static Значение Гармония(int64_t з) { return Значение(ЗначениеГармония(з)); }
    static Значение Целое(int64_t з) { return Значение(з); }
    static Значение Строка(const std::string& с) { return Значение(с); }
    static Значение Трибоначчи(int64_t з) { return Значение(Тринити::Трибоначчи(з)); }
    static Значение Вещественное(double з) { return Значение(Тринити::ТроичноеВещественное(з)); }
    static Значение Объект(std::shared_ptr<ЭкземплярКласса> об) { return Значение(std::move(об)); }
    static Значение Словарь() { return Значение(std::make_shared<ЗначениеСловарь>()); }
    
    // Проверки типа
    [[nodiscard]] bool пусто() const { return std::holds_alternative<std::monostate>(данные_); }
    [[nodiscard]] bool этоТрит() const { return std::holds_alternative<ЗначениеТрит>(данные_); }
    [[nodiscard]] bool этоГармония() const { return std::holds_alternative<ЗначениеГармония>(данные_); }
    [[nodiscard]] bool этоЦелое() const { return std::holds_alternative<int64_t>(данные_); }
    [[nodiscard]] bool этоДробное() const { 
        return std::holds_alternative<double>(данные_) || 
               std::holds_alternative<Тринити::ТроичноеВещественное>(данные_); 
    }
    [[nodiscard]] bool этоСтрока() const { return std::holds_alternative<std::string>(данные_); }
    [[nodiscard]] bool этоСимвол() const { return std::holds_alternative<char32_t>(данные_); }
    [[nodiscard]] bool этоЛогика() const { return std::holds_alternative<bool>(данные_); }
    [[nodiscard]] bool этоСписок() const { return std::holds_alternative<std::vector<Значение>>(данные_); }
    [[nodiscard]] bool этоФункция() const { 
        return std::holds_alternative<ВстроеннаяФункция>(данные_) ||
               std::holds_alternative<std::shared_ptr<ПользовательскаяФункция>>(данные_);
    }
    [[nodiscard]] bool этоТрибоначчи() const { return std::holds_alternative<Тринити::Трибоначчи>(данные_); }
    [[nodiscard]] bool этоВещественное() const { return std::holds_alternative<Тринити::ТроичноеВещественное>(данные_); }
    [[nodiscard]] bool этоОбъект() const { return std::holds_alternative<std::shared_ptr<ЭкземплярКласса>>(данные_); }
    [[nodiscard]] bool этоСловарь() const { return std::holds_alternative<std::shared_ptr<ЗначениеСловарь>>(данные_); }
    
    // Получение значений
    [[nodiscard]] ЗначениеТрит какТрит() const { return std::get<ЗначениеТрит>(данные_); }
    [[nodiscard]] ЗначениеГармония какГармония() const { return std::get<ЗначениеГармония>(данные_); }
    [[nodiscard]] int64_t какЦелое() const { return std::get<int64_t>(данные_); }
    [[nodiscard]] double какДробное() const { 
        if (std::holds_alternative<double>(данные_)) {
            return std::get<double>(данные_);
        }
        if (std::holds_alternative<Тринити::ТроичноеВещественное>(данные_)) {
            return std::get<Тринити::ТроичноеВещественное>(данные_).вDouble();
        }
        return 0.0;
    }
    [[nodiscard]] const std::string& какСтрока() const { return std::get<std::string>(данные_); }
    [[nodiscard]] char32_t какСимвол() const { return std::get<char32_t>(данные_); }
    [[nodiscard]] bool какЛогика() const { return std::get<bool>(данные_); }
    [[nodiscard]] const std::vector<Значение>& какСписок() const { return std::get<std::vector<Значение>>(данные_); }
    [[nodiscard]] std::vector<Значение>& какСписок() { return std::get<std::vector<Значение>>(данные_); }
    [[nodiscard]] const Тринити::Трибоначчи& какТрибоначчи() const { return std::get<Тринити::Трибоначчи>(данные_); }
    [[nodiscard]] const Тринити::ТроичноеВещественное& какВещественное() const { return std::get<Тринити::ТроичноеВещественное>(данные_); }
    [[nodiscard]] std::shared_ptr<ЭкземплярКласса> какОбъект() const { return std::get<std::shared_ptr<ЭкземплярКласса>>(данные_); }
    [[nodiscard]] std::shared_ptr<ЗначениеСловарь> какСловарь() const { return std::get<std::shared_ptr<ЗначениеСловарь>>(данные_); }
    
    // Преобразования
    [[nodiscard]] int64_t вЦелое() const;
    [[nodiscard]] ЗначениеТрит вТрит() const;
    [[nodiscard]] ЗначениеГармония вГармонию() const;
    [[nodiscard]] std::string вСтроку() const;
    [[nodiscard]] bool вЛогику() const;  // Истинность для условий
    
    // Доступ к данным
    [[nodiscard]] const Вариант& данные() const { return данные_; }
    
private:
    Вариант данные_;
};

// =============================================================================
// Классы и словари (полные определения)
// =============================================================================

/**
 * @brief Определение класса
 */
struct ОпределениеКласса {
    std::string имя;
    std::string родитель;
    std::map<std::string, Значение> поля;
    std::map<std::string, std::shared_ptr<ПользовательскаяФункция>> методы;
    std::shared_ptr<ОпределениеКласса> родительскийКласс;
};

/**
 * @brief Экземпляр класса (объект)
 */
struct ЭкземплярКласса {
    std::shared_ptr<ОпределениеКласса> класс;
    std::map<std::string, Значение> поля;
    
    explicit ЭкземплярКласса(std::shared_ptr<ОпределениеКласса> к) : класс(std::move(к)) {
        // Копируем поля по умолчанию
        if (класс) {
            поля = класс->поля;
        }
    }
};

/**
 * @brief Словарь (хеш-таблица)
 */
struct ЗначениеСловарь {
    std::map<std::string, Значение> данные;
    
    ЗначениеСловарь() = default;
    
    void установить(const std::string& ключ, Значение значение) {
        данные[ключ] = std::move(значение);
    }
    
    Значение* получить(const std::string& ключ) {
        auto it = данные.find(ключ);
        return it != данные.end() ? &it->second : nullptr;
    }
    
    bool содержит(const std::string& ключ) const {
        return данные.find(ключ) != данные.end();
    }
    
    size_t размер() const { return данные.size(); }
};

// =============================================================================
// Среда выполнения
// =============================================================================

/**
 * @brief Среда выполнения (хранит переменные)
 */
class СредаВыполнения {
public:
    explicit СредаВыполнения(std::shared_ptr<СредаВыполнения> родитель = nullptr);
    
    /// Определить переменную
    void определить(const std::string& имя, Значение значение);
    
    /// Присвоить значение существующей переменной
    bool присвоить(const std::string& имя, Значение значение);
    
    /// Получить значение переменной
    [[nodiscard]] Значение* получить(const std::string& имя);
    [[nodiscard]] const Значение* получить(const std::string& имя) const;
    
    /// Проверить существование
    [[nodiscard]] bool существует(const std::string& имя) const;
    
    /// Родительская среда
    [[nodiscard]] std::shared_ptr<СредаВыполнения> родитель() const { return родитель_; }

private:
    std::map<std::string, Значение> переменные_;
    std::shared_ptr<СредаВыполнения> родитель_;
};

// =============================================================================
// Исключения
// =============================================================================

/**
 * @brief Ошибка времени выполнения
 */
class ОшибкаВыполнения : public std::runtime_error {
public:
    ОшибкаВыполнения(const std::string& сообщение, Позиция позиция = Позиция())
        : std::runtime_error(сообщение), позиция_(позиция) {}
    
    [[nodiscard]] const Позиция& позиция() const noexcept { return позиция_; }

private:
    Позиция позиция_;
};

/**
 * @brief Сигнал возврата из функции
 */
class СигналВозврат : public std::exception {
public:
    explicit СигналВозврат(Значение значение) : значение_(std::move(значение)) {}
    [[nodiscard]] const Значение& значение() const noexcept { return значение_; }
private:
    Значение значение_;
};

/**
 * @brief Сигнал прерывания цикла
 */
class СигналПрервать : public std::exception {};

/**
 * @brief Сигнал продолжения цикла
 */
class СигналПродолжить : public std::exception {};

// =============================================================================
// Интерпретатор
// =============================================================================

/**
 * @brief Интерпретатор языка "Троица"
 * 
 * Выполняет AST программы, вычисляя выражения и исполняя инструкции.
 * Поддерживает троичную логику и типы данных.
 */
class Интерпретатор {
public:
    Интерпретатор();
    
    /// Выполнить программу
    Значение выполнить(Древо::Программа& программа);
    
    /// Выполнить инструкцию
    void выполнитьИнструкцию(Древо::Инструкция* инструкция);
    
    /// Вычислить выражение
    Значение вычислить(Древо::Выражение* выражение);
    
    /// Вызвать функцию
    Значение вызватьФункцию(const Значение& функция, const std::vector<Значение>& аргументы);
    
    /// Получить глобальную среду
    [[nodiscard]] std::shared_ptr<СредаВыполнения> глобальнаяСреда() const { return глобальная_; }
    
    /// Получить текущую среду
    [[nodiscard]] std::shared_ptr<СредаВыполнения> текущаяСреда() const { return текущая_; }
    
    /// Установить обработчик вывода
    void установитьВывод(std::function<void(const std::string&)> обработчик) {
        обработчикВывода_ = std::move(обработчик);
    }
    
    /// Установить обработчик ввода
    void установитьВвод(std::function<std::string()> обработчик) {
        обработчикВвода_ = std::move(обработчик);
    }
    
    /// Вывести строку
    void вывести(const std::string& текст);
    
    /// Прочитать строку
    std::string ввести();

private:
    std::shared_ptr<СредаВыполнения> глобальная_;
    std::shared_ptr<СредаВыполнения> текущая_;
    
    std::function<void(const std::string&)> обработчикВывода_;
    std::function<std::string()> обработчикВвода_;
    
    // Реестр классов
    std::map<std::string, std::shared_ptr<ОпределениеКласса>> классы_;
    
    // Загруженные модули
    std::map<std::string, bool> загруженныеМодули_;
    
    // === Выполнение инструкций ===
    
    void выполнитьПусть(Древо::Пусть* узел);
    void выполнитьПрисвоить(Древо::Присвоить* узел);
    void выполнитьЕсли(Древо::Если* узел);
    void выполнитьВыбор(Древо::Выбор* узел);
    void выполнитьПока(Древо::Пока* узел);
    void выполнитьДля(Древо::Для* узел);
    void выполнитьЦикл(Древо::Цикл* узел);
    void выполнитьВернуть(Древо::Вернуть* узел);
    void выполнитьБлок(Древо::Блок* узел);
    void выполнитьОбъявФункция(Древо::ОбъявФункция* узел);
    void выполнитьОбъявКласс(Древо::ОбъявКласс* узел);
    void выполнитьИмпорт(Древо::ОбъявИмпорт* узел);
    
    // === Вычисление выражений ===
    
    Значение вычислитьИмя(Древо::Имя* узел);
    Значение вычислитьЧисло(Древо::ЗначениеЧисло* узел);
    Значение вычислитьВещественное(Древо::ЗначениеВещественное* узел);
    Значение вычислитьСтрока(Древо::ЗначениеСтрока* узел);
    Значение вычислитьЛогика(Древо::ЗначениеЛогика* узел);
    Значение вычислитьДвойнаяОперация(Древо::ДвойнаяОперация* узел);
    Значение вычислитьОднарнаяОперация(Древо::ОднарнаяОперация* узел);
    Значение вычислитьВызов(Древо::Вызов* узел);
    Значение вычислитьДоступ(Древо::Доступ* узел);
    Значение вычислитьИндекс(Древо::Индекс* узел);
    Значение вычислитьНовыйОбъект(Древо::НовыйОбъект* узел);
    Значение вычислитьСловарь(Древо::ЗначениеСловарь* узел);
    Значение вычислитьСписок(Древо::ЗначениеСписок* узел);
    
    // === Операции ===
    
    Значение сложить(const Значение& а, const Значение& б);
    Значение вычесть(const Значение& а, const Значение& б);
    Значение умножить(const Значение& а, const Значение& б);
    Значение разделить(const Значение& а, const Значение& б);
    Значение остаток(const Значение& а, const Значение& б);
    Значение сравнить(ТипТокена оп, const Значение& а, const Значение& б);
    Значение логическаяОперация(ТипТокена оп, const Значение& а, const Значение& б);
    
    // === Вспомогательные ===
    
    void зарегистрироватьВстроенные();
    void войтиВСреду();
    void выйтиИзСреды();
};

} // namespace Троица

#endif // T9_TROITSA_INTERPRETER_HPP
