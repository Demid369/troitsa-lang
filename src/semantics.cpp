/**
 * @file: semantics.cpp
 * @description: Реализация семантического анализатора языка "Троица"
 * @dependencies: semantics.hpp
 * @created: 2026-02-02
 */

#include "troitsa/semantics.hpp"
#include <sstream>
#include <algorithm>

namespace Троица {

// =============================================================================
// Тип
// =============================================================================

std::string Тип::вСтроку() const {
    if (параметры.empty()) {
        return имя;
    }
    
    std::string результат = имя + "<";
    for (size_t i = 0; i < параметры.size(); ++i) {
        if (i > 0) результат += ", ";
        результат += параметры[i]->вСтроку();
    }
    результат += ">";
    return результат;
}

bool Тип::совместим(const Тип& другой) const {
    // Ошибочный тип совместим со всем (чтобы не плодить ошибки)
    if (ошибка() || другой.ошибка()) return true;
    
    // Неизвестный тип совместим со всем
    if (неизвестный() || другой.неизвестный()) return true;
    
    // Точное совпадение
    if (*this == другой) return true;
    
    // Троичные типы совместимы между собой (с неявным преобразованием)
    if (троичный() && другой.троичный()) {
        // Трит -> Трайт -> Гармония (расширение)
        // Но не наоборот без явного преобразования
        if (имя == "Трит") return true;  // Трит совместим со всеми троичными
        if (имя == "Трайт" && другой.имя != "Трит") return true;
        if (имя == "Гармония") return другой.имя == "Гармония";
    }
    
    // Целое совместимо с троичными
    if (имя == "Целое" && другой.троичный()) return true;
    if (троичный() && другой.имя == "Целое") return true;
    
    // Логика совместима с Трит
    if ((имя == "Логика" && другой.имя == "Трит") ||
        (имя == "Трит" && другой.имя == "Логика")) return true;
    
    return false;
}

// =============================================================================
// Встроенные типы
// =============================================================================

namespace Типы {

static std::map<std::string, УказательТип> кэш;

УказательТип Трит() {
    if (!кэш["Трит"]) {
        кэш["Трит"] = std::make_shared<Тип>(КатегорияТипа::Примитив, "Трит");
    }
    return кэш["Трит"];
}

УказательТип Трайт() {
    if (!кэш["Трайт"]) {
        кэш["Трайт"] = std::make_shared<Тип>(КатегорияТипа::Примитив, "Трайт");
    }
    return кэш["Трайт"];
}

УказательТип Гармония() {
    if (!кэш["Гармония"]) {
        кэш["Гармония"] = std::make_shared<Тип>(КатегорияТипа::Примитив, "Гармония");
    }
    return кэш["Гармония"];
}

УказательТип Логика() {
    if (!кэш["Логика"]) {
        кэш["Логика"] = std::make_shared<Тип>(КатегорияТипа::Примитив, "Логика");
    }
    return кэш["Логика"];
}

УказательТип Целое() {
    if (!кэш["Целое"]) {
        кэш["Целое"] = std::make_shared<Тип>(КатегорияТипа::Примитив, "Целое");
    }
    return кэш["Целое"];
}

УказательТип Вещественное() {
    if (!кэш["Вещественное"]) {
        кэш["Вещественное"] = std::make_shared<Тип>(КатегорияТипа::Примитив, "Вещественное");
    }
    return кэш["Вещественное"];
}

УказательТип Строка() {
    if (!кэш["Строка"]) {
        кэш["Строка"] = std::make_shared<Тип>(КатегорияТипа::Строковый, "Строка");
    }
    return кэш["Строка"];
}

УказательТип Символ() {
    if (!кэш["Символ"]) {
        кэш["Символ"] = std::make_shared<Тип>(КатегорияТипа::Примитив, "Символ");
    }
    return кэш["Символ"];
}

УказательТип Пусто() {
    if (!кэш["Пусто"]) {
        кэш["Пусто"] = std::make_shared<Тип>(КатегорияТипа::Примитив, "Пусто");
    }
    return кэш["Пусто"];
}

УказательТип Неизвестный() {
    return std::make_shared<Тип>(КатегорияТипа::Неизвестный, "?");
}

УказательТип Ошибка() {
    return std::make_shared<Тип>(КатегорияТипа::Ошибка, "ошибка");
}

УказательТип Список(УказательТип элемент) {
    auto тип = std::make_shared<Тип>(КатегорияТипа::Составной, "Список");
    тип->параметры.push_back(std::move(элемент));
    return тип;
}

УказательТип Словарь(УказательТип ключ, УказательТип значение) {
    auto тип = std::make_shared<Тип>(КатегорияТипа::Составной, "Словарь");
    тип->параметры.push_back(std::move(ключ));
    тип->параметры.push_back(std::move(значение));
    return тип;
}

УказательТип Возможно(УказательТип внутренний) {
    auto тип = std::make_shared<Тип>(КатегорияТипа::Возможно, "Возможно");
    тип->параметры.push_back(std::move(внутренний));
    return тип;
}

УказательТип Функция(std::vector<УказательТип> параметры, УказательТип возврат) {
    auto тип = std::make_shared<Тип>(КатегорияТипа::Функция, "Функция");
    тип->параметры = std::move(параметры);
    тип->параметры.push_back(std::move(возврат));
    return тип;
}

} // namespace Типы

// =============================================================================
// ОбластьВидимости
// =============================================================================

ОбластьВидимости::ОбластьВидимости(std::shared_ptr<ОбластьВидимости> родитель)
    : родитель_(std::move(родитель))
    , глубина_(родитель_ ? родитель_->глубина() + 1 : 0)
{
}

bool ОбластьВидимости::добавить(const Символ& символ) {
    if (существуетЛокально(символ.имя)) {
        return false;  // Уже существует в этой области
    }
    символы_[символ.имя] = символ;
    return true;
}

Символ* ОбластьВидимости::найтиЛокально(const std::string& имя) {
    auto it = символы_.find(имя);
    if (it != символы_.end()) {
        return &it->second;
    }
    return nullptr;
}

Символ* ОбластьВидимости::найти(const std::string& имя) {
    // Ищем в текущей области
    if (auto* символ = найтиЛокально(имя)) {
        return символ;
    }
    // Ищем в родительской
    if (родитель_) {
        return родитель_->найти(имя);
    }
    return nullptr;
}

bool ОбластьВидимости::существует(const std::string& имя) const {
    if (существуетЛокально(имя)) return true;
    if (родитель_) return родитель_->существует(имя);
    return false;
}

bool ОбластьВидимости::существуетЛокально(const std::string& имя) const {
    return символы_.find(имя) != символы_.end();
}

// =============================================================================
// ТаблицаСимволов
// =============================================================================

ТаблицаСимволов::ТаблицаСимволов() {
    глобальная_ = std::make_shared<ОбластьВидимости>();
    текущая_ = глобальная_;
}

void ТаблицаСимволов::войтиВОбласть() {
    текущая_ = std::make_shared<ОбластьВидимости>(текущая_);
}

void ТаблицаСимволов::выйтиИзОбласти() {
    if (текущая_ && текущая_->родитель()) {
        текущая_ = текущая_->родитель();
    }
}

bool ТаблицаСимволов::добавить(const Символ& символ) {
    return текущая_->добавить(символ);
}

Символ* ТаблицаСимволов::найти(const std::string& имя) {
    return текущая_->найти(имя);
}

bool ТаблицаСимволов::существует(const std::string& имя) const {
    return текущая_->существует(имя);
}

// =============================================================================
// СемантическаяОшибка
// =============================================================================

std::string СемантическаяОшибка::вСтроку() const {
    std::ostringstream oss;
    
    switch (уровень) {
        case УровеньОшибки::Подсказка: oss << "подсказка"; break;
        case УровеньОшибки::Предупреждение: oss << "предупреждение"; break;
        case УровеньОшибки::Ошибка: oss << "ошибка"; break;
        case УровеньОшибки::Критическая: oss << "КРИТИЧЕСКАЯ"; break;
    }
    
    if (!код.empty()) {
        oss << "[" << код << "]";
    }
    
    oss << " " << позиция.вСтроку() << ": " << сообщение;
    
    return oss.str();
}

// =============================================================================
// СемантическийАнализатор — основные методы
// =============================================================================

СемантическийАнализатор::СемантическийАнализатор()
    : текущийВозвращаемыйТип_(nullptr)
    , вЦикле_(false)
    , вФункции_(false)
{
    зарегистрироватьВстроенные();
}

bool СемантическийАнализатор::анализировать(Древо::Программа& программа) {
    ошибки_.clear();
    
    // Анализируем все объявления
    for (auto& объявление : программа.объявления) {
        анализироватьИнструкцию(объявление.get());
    }
    
    // Проверяем неиспользованные переменные
    for (auto& [имя, символ] : таблица_.глобальнаяОбласть()->символы()) {
        if (!символ.использован && символ.вид == ВидСимвола::Переменная) {
            предупреждение("Переменная '" + имя + "' объявлена, но не используется",
                          символ.позиция, "W001");
        }
    }
    
    return !естьОшибки();
}

bool СемантическийАнализатор::естьОшибки() const {
    return std::any_of(ошибки_.begin(), ошибки_.end(), [](const СемантическаяОшибка& о) {
        return о.уровень == УровеньОшибки::Ошибка || о.уровень == УровеньОшибки::Критическая;
    });
}

size_t СемантическийАнализатор::количествоОшибок() const {
    return std::count_if(ошибки_.begin(), ошибки_.end(), [](const СемантическаяОшибка& о) {
        return о.уровень == УровеньОшибки::Ошибка || о.уровень == УровеньОшибки::Критическая;
    });
}

size_t СемантическийАнализатор::количествоПредупреждений() const {
    return std::count_if(ошибки_.begin(), ошибки_.end(), [](const СемантическаяОшибка& о) {
        return о.уровень == УровеньОшибки::Предупреждение;
    });
}

// =============================================================================
// Анализ инструкций
// =============================================================================

void СемантическийАнализатор::анализироватьИнструкцию(Древо::Инструкция* инструкция) {
    if (!инструкция) return;
    
    switch (инструкция->тип) {
        case Древо::ТипУзла::Пусть:
            анализироватьПусть(static_cast<Древо::Пусть*>(инструкция));
            break;
        case Древо::ТипУзла::Присвоить:
            анализироватьПрисвоить(static_cast<Древо::Присвоить*>(инструкция));
            break;
        case Древо::ТипУзла::Если:
            анализироватьЕсли(static_cast<Древо::Если*>(инструкция));
            break;
        case Древо::ТипУзла::Выбор:
            анализироватьВыбор(static_cast<Древо::Выбор*>(инструкция));
            break;
        case Древо::ТипУзла::Пока:
            анализироватьПока(static_cast<Древо::Пока*>(инструкция));
            break;
        case Древо::ТипУзла::Для:
            анализироватьДля(static_cast<Древо::Для*>(инструкция));
            break;
        case Древо::ТипУзла::Цикл:
            анализироватьЦикл(static_cast<Древо::Цикл*>(инструкция));
            break;
        case Древо::ТипУзла::Вернуть:
            анализироватьВернуть(static_cast<Древо::Вернуть*>(инструкция));
            break;
        case Древо::ТипУзла::Прервать:
            анализироватьПрервать(static_cast<Древо::Прервать*>(инструкция));
            break;
        case Древо::ТипУзла::Продолжить:
            анализироватьПродолжить(static_cast<Древо::Продолжить*>(инструкция));
            break;
        case Древо::ТипУзла::Блок:
            анализироватьБлок(static_cast<Древо::Блок*>(инструкция));
            break;
        case Древо::ТипУзла::ОбъявФункция:
            анализироватьОбъявФункция(static_cast<Древо::ОбъявФункция*>(инструкция));
            break;
        case Древо::ТипУзла::ВыражениеИнструкция: {
            auto* выр = static_cast<Древо::ВыражениеИнструкция*>(инструкция);
            анализироватьВыражение(выр->выражение.get());
            break;
        }
        default:
            break;
    }
}

void СемантическийАнализатор::анализироватьПусть(Древо::Пусть* узел) {
    // Проверяем, не существует ли уже переменная в текущей области
    if (таблица_.текущаяОбласть()->существуетЛокально(узел->имя)) {
        ошибка("Переменная '" + узел->имя + "' уже объявлена в этой области видимости",
               узел->позиция, "E001");
        return;
    }
    
    // Анализируем инициализатор
    УказательТип типЗначения = Типы::Неизвестный();
    if (узел->значение) {
        типЗначения = анализироватьВыражение(узел->значение.get());
    }
    
    // Определяем тип переменной
    УказательТип типПеременной;
    if (!узел->тип.empty()) {
        // Явно указан тип
        типПеременной = разрешитьТип(узел->тип);
        if (типПеременной->ошибка()) {
            ошибка("Неизвестный тип '" + узел->тип + "'", узел->позиция, "E002");
        } else if (узел->значение && !проверитьПрисваивание(типПеременной, типЗначения, узел->позиция)) {
            // Ошибка уже зарегистрирована в проверитьПрисваивание
        }
    } else if (узел->значение) {
        // Выводим тип из значения
        типПеременной = типЗначения;
    } else {
        ошибка("Невозможно вывести тип переменной '" + узел->имя + "' без инициализатора",
               узел->позиция, "E003");
        типПеременной = Типы::Ошибка();
    }
    
    // Добавляем в таблицу символов
    Символ символ(узел->имя, ВидСимвола::Переменная, типПеременной, узел->позиция);
    символ.инициализирован = узел->значение != nullptr;
    символ.изменяемый = узел->изменяемый;
    таблица_.добавить(символ);
}

void СемантическийАнализатор::анализироватьПрисвоить(Древо::Присвоить* узел) {
    auto типЦели = анализироватьВыражение(узел->цель.get());
    auto типЗначения = анализироватьВыражение(узел->значение.get());
    
    // Проверяем, что цель — изменяемая переменная
    if (auto* имя = dynamic_cast<Древо::Имя*>(узел->цель.get())) {
        if (auto* символ = таблица_.найти(имя->имя)) {
            if (!символ->изменяемый) {
                ошибка("Невозможно присвоить значение неизменяемой переменной '" + имя->имя + "'",
                       узел->позиция, "E004");
            }
            символ->инициализирован = true;
        }
    }
    
    проверитьПрисваивание(типЦели, типЗначения, узел->позиция);
}

void СемантическийАнализатор::анализироватьЕсли(Древо::Если* узел) {
    auto типУсловия = анализироватьВыражение(узел->условие.get());
    проверитьУсловие(типУсловия, узел->условие->позиция);
    
    таблица_.войтиВОбласть();
    анализироватьИнструкцию(узел->тогда.get());
    таблица_.выйтиИзОбласти();
    
    if (узел->иначе) {
        таблица_.войтиВОбласть();
        анализироватьИнструкцию(узел->иначе.get());
        таблица_.выйтиИзОбласти();
    }
}

void СемантическийАнализатор::анализироватьВыбор(Древо::Выбор* узел) {
    auto типЗначения = анализироватьВыражение(узел->значение.get());
    
    // Для троичного выбора значение должно быть Логика или Трит
    if (!типЗначения->троичный() && типЗначения->имя != "Логика") {
        предупреждение("Выбор обычно используется с троичными типами (Логика, Трит)",
                      узел->позиция, "W002");
    }
    
    bool естьДа = false, естьНет = false, естьМожет = false;
    
    for (auto& ветка : узел->ветки) {
        таблица_.войтиВОбласть();
        
        // Проверяем образец
        if (ветка.образец) {
            auto типОбразца = анализироватьВыражение(ветка.образец.get());
            
            // Проверяем покрытие троичных значений
            if (auto* логика = dynamic_cast<Древо::ЗначениеЛогика*>(ветка.образец.get())) {
                if (логика->значение == +1) естьДа = true;
                if (логика->значение == -1) естьНет = true;
                if (логика->значение == 0) естьМожет = true;
            }
        }
        
        анализироватьИнструкцию(ветка.тело.get());
        таблица_.выйтиИзОбласти();
    }
    
    // Предупреждаем о неполном покрытии
    if (типЗначения->троичный() || типЗначения->имя == "Логика") {
        if (!естьДа || !естьНет || !естьМожет) {
            предупреждение("Выбор не покрывает все троичные значения (Да, Нет, Может)",
                          узел->позиция, "W003");
        }
    }
}

void СемантическийАнализатор::анализироватьПока(Древо::Пока* узел) {
    auto типУсловия = анализироватьВыражение(узел->условие.get());
    проверитьУсловие(типУсловия, узел->условие->позиция);
    
    bool былВЦикле = вЦикле_;
    вЦикле_ = true;
    
    таблица_.войтиВОбласть();
    анализироватьИнструкцию(узел->тело.get());
    таблица_.выйтиИзОбласти();
    
    вЦикле_ = былВЦикле;
}

void СемантическийАнализатор::анализироватьДля(Древо::Для* узел) {
    auto типКоллекции = анализироватьВыражение(узел->коллекция.get());
    
    // Определяем тип элемента коллекции
    УказательТип типЭлемента = Типы::Неизвестный();
    if (типКоллекции->категория == КатегорияТипа::Составной && 
        типКоллекции->имя == "Список" && !типКоллекции->параметры.empty()) {
        типЭлемента = типКоллекции->параметры[0];
    } else if (типКоллекции->имя == "Строка") {
        типЭлемента = Типы::Символ();
    }
    
    bool былВЦикле = вЦикле_;
    вЦикле_ = true;
    
    таблица_.войтиВОбласть();
    
    // Добавляем переменную цикла
    Символ переменная(узел->переменная, ВидСимвола::Переменная, типЭлемента, узел->позиция);
    переменная.инициализирован = true;
    переменная.изменяемый = false;
    таблица_.добавить(переменная);
    
    анализироватьИнструкцию(узел->тело.get());
    таблица_.выйтиИзОбласти();
    
    вЦикле_ = былВЦикле;
}

void СемантическийАнализатор::анализироватьЦикл(Древо::Цикл* узел) {
    bool былВЦикле = вЦикле_;
    вЦикле_ = true;
    
    таблица_.войтиВОбласть();
    анализироватьИнструкцию(узел->тело.get());
    таблица_.выйтиИзОбласти();
    
    вЦикле_ = былВЦикле;
}

void СемантическийАнализатор::анализироватьВернуть(Древо::Вернуть* узел) {
    if (!вФункции_) {
        ошибка("'вернуть' вне функции", узел->позиция, "E005");
        return;
    }
    
    УказательТип типЗначения = Типы::Пусто();
    if (узел->значение) {
        типЗначения = анализироватьВыражение(узел->значение.get());
    }
    
    if (текущийВозвращаемыйТип_ && !текущийВозвращаемыйТип_->совместим(*типЗначения)) {
        ошибка("Тип возвращаемого значения '" + типЗначения->вСтроку() + 
               "' не совместим с объявленным '" + текущийВозвращаемыйТип_->вСтроку() + "'",
               узел->позиция, "E006");
    }
}

void СемантическийАнализатор::анализироватьПрервать(Древо::Прервать* узел) {
    if (!вЦикле_) {
        ошибка("'прервать' вне цикла", узел->позиция, "E007");
    }
}

void СемантическийАнализатор::анализироватьПродолжить(Древо::Продолжить* узел) {
    if (!вЦикле_) {
        ошибка("'продолжить' вне цикла", узел->позиция, "E008");
    }
}

void СемантическийАнализатор::анализироватьБлок(Древо::Блок* узел) {
    таблица_.войтиВОбласть();
    
    for (auto& инструкция : узел->инструкции) {
        анализироватьИнструкцию(инструкция.get());
    }
    
    // Проверяем неиспользованные переменные в блоке
    for (auto& [имя, символ] : таблица_.текущаяОбласть()->символы()) {
        if (!символ.использован && символ.вид == ВидСимвола::Переменная) {
            предупреждение("Переменная '" + имя + "' объявлена, но не используется",
                          символ.позиция, "W001");
        }
    }
    
    таблица_.выйтиИзОбласти();
}

void СемантическийАнализатор::анализироватьОбъявФункция(Древо::ОбъявФункция* узел) {
    // Проверяем, не существует ли уже функция
    if (таблица_.глобальнаяОбласть()->существуетЛокально(узел->имя)) {
        ошибка("Функция '" + узел->имя + "' уже объявлена", узел->позиция, "E009");
        return;
    }
    
    // Собираем типы параметров
    std::vector<УказательТип> типыПараметров;
    for (auto& параметр : узел->параметры) {
        auto тип = разрешитьТип(параметр.тип);
        if (тип->ошибка()) {
            ошибка("Неизвестный тип параметра '" + параметр.тип + "'", узел->позиция, "E002");
        }
        типыПараметров.push_back(тип);
    }
    
    // Разрешаем возвращаемый тип
    УказательТип возвращаемыйТип = Типы::Пусто();
    if (!узел->возвращаемыйТип.empty()) {
        возвращаемыйТип = разрешитьТип(узел->возвращаемыйТип);
        if (возвращаемыйТип->ошибка()) {
            ошибка("Неизвестный возвращаемый тип '" + узел->возвращаемыйТип + "'", 
                   узел->позиция, "E002");
        }
    }
    
    // Создаём тип функции
    auto типФункции = Типы::Функция(типыПараметров, возвращаемыйТип);
    
    // Добавляем функцию в глобальную область
    Символ символФункции(узел->имя, ВидСимвола::Функция, типФункции, узел->позиция);
    символФункции.инициализирован = true;
    таблица_.глобальнаяОбласть()->добавить(символФункции);
    
    // Анализируем тело функции
    bool былВФункции = вФункции_;
    auto предыдущийВозврат = текущийВозвращаемыйТип_;
    
    вФункции_ = true;
    текущийВозвращаемыйТип_ = возвращаемыйТип;
    
    таблица_.войтиВОбласть();
    
    // Добавляем параметры
    for (size_t i = 0; i < узел->параметры.size(); ++i) {
        Символ параметр(узел->параметры[i].имя, ВидСимвола::Параметр, 
                        типыПараметров[i], узел->позиция);
        параметр.инициализирован = true;
        параметр.изменяемый = false;
        таблица_.добавить(параметр);
    }
    
    анализироватьИнструкцию(узел->тело.get());
    
    таблица_.выйтиИзОбласти();
    
    вФункции_ = былВФункции;
    текущийВозвращаемыйТип_ = предыдущийВозврат;
}

// =============================================================================
// Анализ выражений
// =============================================================================

УказательТип СемантическийАнализатор::анализироватьВыражение(Древо::Выражение* выражение) {
    if (!выражение) return Типы::Ошибка();
    
    switch (выражение->тип) {
        case Древо::ТипУзла::Имя:
            return анализироватьИмя(static_cast<Древо::Имя*>(выражение));
        case Древо::ТипУзла::ЗначениеЧисло:
            return анализироватьЧисло(static_cast<Древо::ЗначениеЧисло*>(выражение));
        case Древо::ТипУзла::ЗначениеСтрока:
            return анализироватьСтрока(static_cast<Древо::ЗначениеСтрока*>(выражение));
        case Древо::ТипУзла::ЗначениеЛогика:
            return анализироватьЛогика(static_cast<Древо::ЗначениеЛогика*>(выражение));
        case Древо::ТипУзла::ДвойнаяОперация:
            return анализироватьДвойнаяОперация(static_cast<Древо::ДвойнаяОперация*>(выражение));
        case Древо::ТипУзла::ОднарнаяОперация:
            return анализироватьОднарнаяОперация(static_cast<Древо::ОднарнаяОперация*>(выражение));
        case Древо::ТипУзла::Вызов:
            return анализироватьВызов(static_cast<Древо::Вызов*>(выражение));
        case Древо::ТипУзла::Доступ:
            return анализироватьДоступ(static_cast<Древо::Доступ*>(выражение));
        case Древо::ТипУзла::Индекс:
            return анализироватьИндекс(static_cast<Древо::Индекс*>(выражение));
        default:
            return Типы::Неизвестный();
    }
}

УказательТип СемантическийАнализатор::анализироватьИмя(Древо::Имя* узел) {
    auto* символ = таблица_.найти(узел->имя);
    
    if (!символ) {
        ошибка("Неизвестный идентификатор '" + узел->имя + "'", узел->позиция, "E010");
        return Типы::Ошибка();
    }
    
    символ->использован = true;
    
    if (!символ->инициализирован) {
        ошибка("Использование неинициализированной переменной '" + узел->имя + "'",
               узел->позиция, "E011");
    }
    
    return символ->тип;
}

УказательТип СемантическийАнализатор::анализироватьЧисло(Древо::ЗначениеЧисло* узел) {
    if (узел->троичное) {
        // Определяем размер по значению
        int64_t знач = узел->значение;
        if (знач >= -1 && знач <= 1) return Типы::Трит();
        if (знач >= -13 && знач <= 13) return Типы::Трайт();
        return Типы::Гармония();
    }
    return Типы::Целое();
}

УказательТип СемантическийАнализатор::анализироватьСтрока(Древо::ЗначениеСтрока* узел) {
    return Типы::Строка();
}

УказательТип СемантическийАнализатор::анализироватьЛогика(Древо::ЗначениеЛогика* узел) {
    return Типы::Логика();
}

УказательТип СемантическийАнализатор::анализироватьДвойнаяОперация(Древо::ДвойнаяОперация* узел) {
    auto типЛевого = анализироватьВыражение(узел->левое.get());
    auto типПравого = анализироватьВыражение(узел->правое.get());
    
    return вывестиТипОперации(узел->оператор, типЛевого, типПравого);
}

УказательТип СемантическийАнализатор::анализироватьОднарнаяОперация(Древо::ОднарнаяОперация* узел) {
    auto типОперанда = анализироватьВыражение(узел->операнд.get());
    return вывестиТипУнарной(узел->оператор, типОперанда);
}

УказательТип СемантическийАнализатор::анализироватьВызов(Древо::Вызов* узел) {
    auto типФункции = анализироватьВыражение(узел->функция.get());
    
    if (типФункции->категория != КатегорияТипа::Функция) {
        if (!типФункции->ошибка()) {
            ошибка("Попытка вызвать не-функцию", узел->позиция, "E012");
        }
        return Типы::Ошибка();
    }
    
    // Проверяем количество аргументов
    size_t ожидаемо = типФункции->параметры.size() - 1;  // -1 для возвращаемого типа
    size_t фактически = узел->аргументы.size();
    
    if (фактически != ожидаемо) {
        ошибка("Неверное количество аргументов: ожидалось " + std::to_string(ожидаемо) +
               ", получено " + std::to_string(фактически), узел->позиция, "E013");
    }
    
    // Проверяем типы аргументов
    for (size_t i = 0; i < std::min(фактически, ожидаемо); ++i) {
        auto типАргумента = анализироватьВыражение(узел->аргументы[i].get());
        auto ожидаемыйТип = типФункции->параметры[i];
        
        if (!ожидаемыйТип->совместим(*типАргумента)) {
            ошибка("Тип аргумента " + std::to_string(i + 1) + " '" + типАргумента->вСтроку() +
                   "' не совместим с ожидаемым '" + ожидаемыйТип->вСтроку() + "'",
                   узел->аргументы[i]->позиция, "E014");
        }
    }
    
    // Возвращаем тип результата (последний в параметрах)
    if (!типФункции->параметры.empty()) {
        return типФункции->параметры.back();
    }
    return Типы::Пусто();
}

УказательТип СемантическийАнализатор::анализироватьДоступ(Древо::Доступ* узел) {
    auto типОбъекта = анализироватьВыражение(узел->объект.get());
    
    // TODO: Реализовать доступ к полям для пользовательских типов
    
    return Типы::Неизвестный();
}

УказательТип СемантическийАнализатор::анализироватьИндекс(Древо::Индекс* узел) {
    auto типОбъекта = анализироватьВыражение(узел->объект.get());
    auto типИндекса = анализироватьВыражение(узел->индекс.get());
    
    // Проверяем, что индекс — числовой
    if (!типИндекса->числовой()) {
        ошибка("Индекс должен быть числовым типом", узел->индекс->позиция, "E015");
    }
    
    // Определяем тип элемента
    if (типОбъекта->категория == КатегорияТипа::Составной && 
        типОбъекта->имя == "Список" && !типОбъекта->параметры.empty()) {
        return типОбъекта->параметры[0];
    }
    
    if (типОбъекта->имя == "Строка") {
        return Типы::Символ();
    }
    
    if (типОбъекта->имя == "Гармония") {
        return Типы::Трит();  // Доступ к триту по индексу
    }
    
    if (типОбъекта->имя == "Трайт") {
        return Типы::Трит();
    }
    
    return Типы::Неизвестный();
}

// =============================================================================
// Проверки типов
// =============================================================================

bool СемантическийАнализатор::проверитьПрисваивание(УказательТип цель, УказательТип значение, Позиция позиция) {
    if (цель->совместим(*значение)) {
        return true;
    }
    
    ошибка("Невозможно присвоить значение типа '" + значение->вСтроку() +
           "' переменной типа '" + цель->вСтроку() + "'", позиция, "E016");
    return false;
}

bool СемантическийАнализатор::проверитьУсловие(УказательТип тип, Позиция позиция) {
    if (тип->имя == "Логика" || тип->имя == "Трит") {
        return true;
    }
    
    ошибка("Условие должно быть типа Логика или Трит, получено '" + тип->вСтроку() + "'",
           позиция, "E017");
    return false;
}

УказательТип СемантическийАнализатор::вывестиТипОперации(ТипТокена оператор, 
                                                          УказательТип левый, 
                                                          УказательТип правый) {
    // Если один из типов — ошибка, возвращаем ошибку
    if (левый->ошибка() || правый->ошибка()) {
        return Типы::Ошибка();
    }
    
    switch (оператор) {
        // Арифметические операции
        case ТипТокена::ОпПлюс:
        case ТипТокена::ОпМинус:
        case ТипТокена::ОпУмножить:
        case ТипТокена::ОпДелить:
        case ТипТокена::ОпОстаток:
            // Для троичных типов возвращаем больший тип
            if (левый->троичный() && правый->троичный()) {
                if (левый->имя == "Гармония" || правый->имя == "Гармония") return Типы::Гармония();
                if (левый->имя == "Трайт" || правый->имя == "Трайт") return Типы::Трайт();
                return Типы::Трит();
            }
            if (левый->числовой() && правый->числовой()) {
                return Типы::Целое();
            }
            // Конкатенация строк
            if (оператор == ТипТокена::ОпПлюс && 
                (левый->имя == "Строка" || правый->имя == "Строка")) {
                return Типы::Строка();
            }
            return Типы::Ошибка();
            
        // Операции сравнения
        case ТипТокена::ОпРавно:
        case ТипТокена::ОпНеРавно:
        case ТипТокена::ОпМеньше:
        case ТипТокена::ОпБольше:
        case ТипТокена::ОпМеньшеРавно:
        case ТипТокена::ОпБольшеРавно:
            return Типы::Логика();
            
        // Логические операции (троичные)
        case ТипТокена::ОпИ:
        case ТипТокена::ОпИли:
        case ТипТокена::ОпКонсенсус:
            if ((левый->троичный() || левый->имя == "Логика") &&
                (правый->троичный() || правый->имя == "Логика")) {
                // Возвращаем больший троичный тип
                if (левый->имя == "Гармония" || правый->имя == "Гармония") return Типы::Гармония();
                if (левый->имя == "Трайт" || правый->имя == "Трайт") return Типы::Трайт();
                if (левый->имя == "Трит" || правый->имя == "Трит") return Типы::Трит();
                return Типы::Логика();
            }
            return Типы::Ошибка();
            
        default:
            return Типы::Неизвестный();
    }
}

УказательТип СемантическийАнализатор::вывестиТипУнарной(ТипТокена оператор, УказательТип операнд) {
    if (операнд->ошибка()) return Типы::Ошибка();
    
    switch (оператор) {
        case ТипТокена::ОпМинус:
            if (операнд->числовой() || операнд->троичный()) {
                return операнд;
            }
            return Типы::Ошибка();
            
        case ТипТокена::ОпНе:
            if (операнд->троичный() || операнд->имя == "Логика") {
                return операнд;
            }
            return Типы::Ошибка();
            
        default:
            return Типы::Неизвестный();
    }
}

УказательТип СемантическийАнализатор::разрешитьТип(const std::string& имя) {
    if (имя == "Трит") return Типы::Трит();
    if (имя == "Трайт") return Типы::Трайт();
    if (имя == "Гармония") return Типы::Гармония();
    if (имя == "Логика") return Типы::Логика();
    if (имя == "Целое") return Типы::Целое();
    if (имя == "Строка") return Типы::Строка();
    if (имя == "Символ") return Типы::Символ();
    if (имя == "Пусто") return Типы::Пусто();
    
    // TODO: Поиск пользовательских типов в таблице символов
    
    return Типы::Ошибка();
}

// =============================================================================
// Регистрация ошибок
// =============================================================================

void СемантическийАнализатор::ошибка(const std::string& сообщение, Позиция позиция, 
                                      const std::string& код) {
    ошибки_.emplace_back(УровеньОшибки::Ошибка, сообщение, позиция, код);
}

void СемантическийАнализатор::предупреждение(const std::string& сообщение, Позиция позиция,
                                              const std::string& код) {
    ошибки_.emplace_back(УровеньОшибки::Предупреждение, сообщение, позиция, код);
}

void СемантическийАнализатор::подсказка(const std::string& сообщение, Позиция позиция,
                                         const std::string& код) {
    ошибки_.emplace_back(УровеньОшибки::Подсказка, сообщение, позиция, код);
}

// =============================================================================
// Встроенные функции
// =============================================================================

void СемантическийАнализатор::зарегистрироватьВстроенные() {
    // Функция вывода (принимает любой тип)
    {
        auto типПечать = Типы::Функция({Типы::Неизвестный()}, Типы::Пусто());
        Символ печать("печать", ВидСимвола::Функция, типПечать);
        печать.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(печать);
    }
    
    // Функция ввода
    {
        auto типВвод = Типы::Функция({}, Типы::Строка());
        Символ ввод("ввод", ВидСимвола::Функция, типВвод);
        ввод.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(ввод);
    }
    
    // Преобразование в Трит
    {
        auto типВТрит = Типы::Функция({Типы::Целое()}, Типы::Трит());
        Символ вТрит("вТрит", ВидСимвола::Функция, типВТрит);
        вТрит.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(вТрит);
    }
    
    // Преобразование в Гармонию
    {
        auto типВГармонию = Типы::Функция({Типы::Целое()}, Типы::Гармония());
        Символ вГармонию("вГармонию", ВидСимвола::Функция, типВГармонию);
        вГармонию.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(вГармонию);
    }
    
    // Абсолютное значение
    {
        auto типМодуль = Типы::Функция({Типы::Гармония()}, Типы::Гармония());
        Символ модуль("модуль", ВидСимвола::Функция, типМодуль);
        модуль.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(модуль);
    }
    
    // Консенсус
    {
        auto типКонсенсус = Типы::Функция({Типы::Трит(), Типы::Трит()}, Типы::Трит());
        Символ консенсус("консенсус", ВидСимвола::Функция, типКонсенсус);
        консенсус.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(консенсус);
    }
    
    // === Функции паттернов 369 ===
    
    // цифр_корень(число) -> Гармония
    {
        auto тип = Типы::Функция({Типы::Целое()}, Типы::Гармония());
        Символ символ("цифр_корень", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // группа_369(число) -> Трит
    {
        auto тип = Типы::Функция({Типы::Целое()}, Типы::Трит());
        Символ символ("группа_369", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // баланс(число) -> Трит
    {
        auto тип = Типы::Функция({Типы::Целое()}, Типы::Трит());
        Символ символ("баланс", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // фибоначчи(n) -> Целое
    {
        auto тип = Типы::Функция({Типы::Целое()}, Типы::Целое());
        Символ символ("фибоначчи", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // === Математические функции ===
    
    // корень(x) -> Вещественное (принимает Целое или Вещественное)
    {
        auto тип = Типы::Функция({Типы::Неизвестный()}, Типы::Вещественное());
        Символ символ("корень", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // син(x) -> Вещественное
    {
        auto тип = Типы::Функция({Типы::Неизвестный()}, Типы::Вещественное());
        Символ символ("син", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // кос(x) -> Вещественное
    {
        auto тип = Типы::Функция({Типы::Неизвестный()}, Типы::Вещественное());
        Символ символ("кос", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // тан(x) -> Вещественное
    {
        auto тип = Типы::Функция({Типы::Неизвестный()}, Типы::Вещественное());
        Символ символ("тан", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // эксп(x) -> Вещественное
    {
        auto тип = Типы::Функция({Типы::Неизвестный()}, Типы::Вещественное());
        Символ символ("эксп", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // лн(x) -> Вещественное
    {
        auto тип = Типы::Функция({Типы::Неизвестный()}, Типы::Вещественное());
        Символ символ("лн", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // степень(x, y) -> Вещественное
    {
        auto тип = Типы::Функция({Типы::Неизвестный(), Типы::Неизвестный()}, Типы::Вещественное());
        Символ символ("степень", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // абс(x) -> Вещественное
    {
        auto тип = Типы::Функция({Типы::Неизвестный()}, Типы::Вещественное());
        Символ символ("абс", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // пол(x) -> Вещественное
    {
        auto тип = Типы::Функция({Типы::Неизвестный()}, Типы::Вещественное());
        Символ символ("пол", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // потолок(x) -> Вещественное
    {
        auto тип = Типы::Функция({Типы::Неизвестный()}, Типы::Вещественное());
        Символ символ("потолок", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // === Константы ===
    
    // пи() -> Вещественное
    {
        auto тип = Типы::Функция({}, Типы::Вещественное());
        Символ символ("пи", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // е() -> Вещественное
    {
        auto тип = Типы::Функция({}, Типы::Вещественное());
        Символ символ("е", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // фи() -> Вещественное
    {
        auto тип = Типы::Функция({}, Типы::Вещественное());
        Символ символ("фи", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // =========================================================================
    // Тороидальная 3D База Данных
    // =========================================================================
    
    // БД_создать(слоёв, путь) -> Трит
    {
        auto тип = Типы::Функция({Типы::Неизвестный(), Типы::Неизвестный()}, Типы::Трит());
        Символ символ("БД_создать", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // БД_вставить(ключ, значение) -> Строка
    {
        auto тип = Типы::Функция({Типы::Неизвестный(), Типы::Неизвестный()}, Типы::Строка());
        Символ символ("БД_вставить", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // БД_найти(ключ) -> Гармония
    {
        auto тип = Типы::Функция({Типы::Неизвестный()}, Типы::Гармония());
        Символ символ("БД_найти", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // БД_обновить(ключ, значение) -> Трит
    {
        auto тип = Типы::Функция({Типы::Неизвестный(), Типы::Неизвестный()}, Типы::Трит());
        Символ символ("БД_обновить", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // БД_удалить(ключ) -> Трит
    {
        auto тип = Типы::Функция({Типы::Неизвестный()}, Типы::Трит());
        Символ символ("БД_удалить", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // БД_существует(ключ) -> Трит
    {
        auto тип = Типы::Функция({Типы::Неизвестный()}, Типы::Трит());
        Символ символ("БД_существует", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // БД_сохранить(путь) -> Трит
    {
        auto тип = Типы::Функция({Типы::Неизвестный()}, Типы::Трит());
        Символ символ("БД_сохранить", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // БД_загрузить(путь) -> Трит
    {
        auto тип = Типы::Функция({Типы::Неизвестный()}, Типы::Трит());
        Символ символ("БД_загрузить", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // БД_всего() -> Целое
    {
        auto тип = Типы::Функция({}, Типы::Целое());
        Символ символ("БД_всего", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // БД_слоёв() -> Целое
    {
        auto тип = Типы::Функция({}, Типы::Целое());
        Символ символ("БД_слоёв", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // БД_визуализация() -> Строка
    {
        auto тип = Типы::Функция({}, Типы::Строка());
        Символ символ("БД_визуализация", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
    
    // БД_закрыть() -> Трит
    {
        auto тип = Типы::Функция({}, Типы::Трит());
        Символ символ("БД_закрыть", ВидСимвола::Функция, тип);
        символ.инициализирован = true;
        таблица_.глобальнаяОбласть()->добавить(символ);
    }
}

} // namespace Троица
