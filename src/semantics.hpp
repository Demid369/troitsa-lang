/**
 * @file: semantics.hpp
 * @description: Семантический анализатор языка "Троица"
 * @dependencies: tree.hpp, token.hpp
 * @created: 2026-02-02
 */

#ifndef T9_TROITSA_SEMANTICS_HPP
#define T9_TROITSA_SEMANTICS_HPP

#include "troitsa/tree.hpp"
#include "troitsa/token.hpp"
#include <string>
#include <vector>
#include <map>
#include <memory>
#include <optional>
#include <functional>

namespace Троица {

// =============================================================================
// Система типов
// =============================================================================

/**
 * @brief Категория типа
 */
enum class КатегорияТипа {
    Примитив,       // Трит, Трайт, Гармония, Логика
    Строковый,      // Строка
    Составной,      // Список, Словарь
    Функция,        // Функциональный тип
    Возможно,       // Возможно<T>
    Результат,      // Результат<T, E>
    Пользовательский, // Определённый пользователем
    Неизвестный,    // Тип ещё не определён
    Ошибка          // Ошибка типизации
};

/**
 * @brief Тип в системе типов "Троицы"
 */
struct Тип {
    КатегорияТипа категория;
    std::string имя;
    std::vector<std::shared_ptr<Тип>> параметры;  // Для обобщённых типов
    bool изменяемый;
    
    Тип() : категория(КатегорияТипа::Неизвестный), изменяемый(false) {}
    
    explicit Тип(КатегорияТипа кат, std::string им = "", bool изм = false)
        : категория(кат), имя(std::move(им)), изменяемый(изм) {}
    
    [[nodiscard]] bool примитив() const noexcept { 
        return категория == КатегорияТипа::Примитив; 
    }
    
    [[nodiscard]] bool троичный() const noexcept {
        return имя == "Трит" || имя == "Трайт" || имя == "Гармония" || имя == "Логика";
    }
    
    [[nodiscard]] bool числовой() const noexcept {
        return имя == "Трит" || имя == "Трайт" || имя == "Гармония" || имя == "Целое";
    }
    
    [[nodiscard]] bool ошибка() const noexcept {
        return категория == КатегорияТипа::Ошибка;
    }
    
    [[nodiscard]] bool неизвестный() const noexcept {
        return категория == КатегорияТипа::Неизвестный;
    }
    
    [[nodiscard]] std::string вСтроку() const;
    
    [[nodiscard]] bool совместим(const Тип& другой) const;
    
    bool operator==(const Тип& другой) const {
        return категория == другой.категория && имя == другой.имя;
    }
    
    bool operator!=(const Тип& другой) const {
        return !(*this == другой);
    }
};

using УказательТип = std::shared_ptr<Тип>;

/**
 * @brief Встроенные типы
 */
namespace Типы {
    УказательТип Трит();
    УказательТип Трайт();
    УказательТип Гармония();
    УказательТип Логика();
    УказательТип Целое();
    УказательТип Вещественное();  // double / ТроичноеВещественное
    УказательТип Строка();
    УказательТип Символ();
    УказательТип Пусто();      // void
    УказательТип Неизвестный();
    УказательТип Ошибка();
    
    УказательТип Список(УказательТип элемент);
    УказательТип Словарь(УказательТип ключ, УказательТип значение);
    УказательТип Возможно(УказательТип внутренний);
    УказательТип Функция(std::vector<УказательТип> параметры, УказательТип возврат);
}

// =============================================================================
// Таблица символов
// =============================================================================

/**
 * @brief Вид символа
 */
enum class ВидСимвола {
    Переменная,
    Параметр,
    Функция,
    Тип,
    Эффект
};

/**
 * @brief Символ в таблице символов
 */
struct Символ {
    std::string имя;
    ВидСимвола вид;
    УказательТип тип;
    bool инициализирован;
    bool использован;
    bool изменяемый;
    Позиция позиция;
    
    Символ() : вид(ВидСимвола::Переменная), инициализирован(false), 
               использован(false), изменяемый(false) {}
    
    Символ(std::string и, ВидСимвола в, УказательТип т, Позиция п = Позиция())
        : имя(std::move(и)), вид(в), тип(std::move(т))
        , инициализирован(false), использован(false), изменяемый(false)
        , позиция(п) {}
};

/**
 * @brief Область видимости
 */
class ОбластьВидимости {
public:
    explicit ОбластьВидимости(std::shared_ptr<ОбластьВидимости> родитель = nullptr);
    
    /// Добавить символ
    bool добавить(const Символ& символ);
    
    /// Найти символ (только в текущей области)
    [[nodiscard]] Символ* найтиЛокально(const std::string& имя);
    
    /// Найти символ (включая родительские области)
    [[nodiscard]] Символ* найти(const std::string& имя);
    
    /// Проверить существование символа
    [[nodiscard]] bool существует(const std::string& имя) const;
    [[nodiscard]] bool существуетЛокально(const std::string& имя) const;
    
    /// Получить родительскую область
    [[nodiscard]] std::shared_ptr<ОбластьВидимости> родитель() const { return родитель_; }
    
    /// Получить все символы
    [[nodiscard]] const std::map<std::string, Символ>& символы() const { return символы_; }
    
    /// Глубина вложенности
    [[nodiscard]] size_t глубина() const { return глубина_; }

private:
    std::map<std::string, Символ> символы_;
    std::shared_ptr<ОбластьВидимости> родитель_;
    size_t глубина_;
};

using УказательОбласть = std::shared_ptr<ОбластьВидимости>;

/**
 * @brief Таблица символов
 */
class ТаблицаСимволов {
public:
    ТаблицаСимволов();
    
    /// Войти в новую область видимости
    void войтиВОбласть();
    
    /// Выйти из текущей области видимости
    void выйтиИзОбласти();
    
    /// Добавить символ в текущую область
    bool добавить(const Символ& символ);
    
    /// Найти символ
    [[nodiscard]] Символ* найти(const std::string& имя);
    
    /// Проверить существование
    [[nodiscard]] bool существует(const std::string& имя) const;
    
    /// Текущая область
    [[nodiscard]] УказательОбласть текущаяОбласть() const { return текущая_; }
    
    /// Глобальная область
    [[nodiscard]] УказательОбласть глобальнаяОбласть() const { return глобальная_; }
    
    /// Глубина вложенности
    [[nodiscard]] size_t глубина() const { return текущая_ ? текущая_->глубина() : 0; }

private:
    УказательОбласть глобальная_;
    УказательОбласть текущая_;
};

// =============================================================================
// Семантические ошибки
// =============================================================================

/**
 * @brief Уровень серьёзности ошибки
 */
enum class УровеньОшибки {
    Подсказка,      // Hint
    Предупреждение, // Warning
    Ошибка,         // Error
    Критическая     // Fatal
};

/**
 * @brief Семантическая ошибка
 */
struct СемантическаяОшибка {
    УровеньОшибки уровень;
    std::string сообщение;
    Позиция позиция;
    std::string код;  // Код ошибки (E001, W002 и т.д.)
    
    СемантическаяОшибка(УровеньОшибки у, std::string с, Позиция п, std::string к = "")
        : уровень(у), сообщение(std::move(с)), позиция(п), код(std::move(к)) {}
    
    [[nodiscard]] std::string вСтроку() const;
};

// =============================================================================
// Семантический анализатор
// =============================================================================

/**
 * @brief Семантический анализатор языка "Троица"
 * 
 * Выполняет:
 * - Проверку типов
 * - Разрешение имён
 * - Проверку инициализации переменных
 * - Проверку использования переменных
 * - Проверку корректности троичных операций
 */
class СемантическийАнализатор {
public:
    СемантическийАнализатор();
    
    /// Анализировать программу
    bool анализировать(Древо::Программа& программа);
    
    /// Получить ошибки
    [[nodiscard]] const std::vector<СемантическаяОшибка>& ошибки() const { return ошибки_; }
    
    /// Есть ли ошибки?
    [[nodiscard]] bool естьОшибки() const;
    
    /// Количество ошибок
    [[nodiscard]] size_t количествоОшибок() const;
    
    /// Количество предупреждений
    [[nodiscard]] size_t количествоПредупреждений() const;
    
    /// Очистить ошибки
    void очиститьОшибки() { ошибки_.clear(); }
    
    /// Получить таблицу символов
    [[nodiscard]] ТаблицаСимволов& таблицаСимволов() { return таблица_; }

private:
    ТаблицаСимволов таблица_;
    std::vector<СемантическаяОшибка> ошибки_;
    
    // Контекст анализа
    УказательТип текущийВозвращаемыйТип_;
    bool вЦикле_;
    bool вФункции_;
    
    // === Анализ узлов ===
    
    void анализироватьИнструкцию(Древо::Инструкция* инструкция);
    УказательТип анализироватьВыражение(Древо::Выражение* выражение);
    
    // Инструкции
    void анализироватьПусть(Древо::Пусть* узел);
    void анализироватьПрисвоить(Древо::Присвоить* узел);
    void анализироватьЕсли(Древо::Если* узел);
    void анализироватьВыбор(Древо::Выбор* узел);
    void анализироватьПока(Древо::Пока* узел);
    void анализироватьДля(Древо::Для* узел);
    void анализироватьЦикл(Древо::Цикл* узел);
    void анализироватьВернуть(Древо::Вернуть* узел);
    void анализироватьПрервать(Древо::Прервать* узел);
    void анализироватьПродолжить(Древо::Продолжить* узел);
    void анализироватьБлок(Древо::Блок* узел);
    void анализироватьОбъявФункция(Древо::ОбъявФункция* узел);
    
    // Выражения
    УказательТип анализироватьИмя(Древо::Имя* узел);
    УказательТип анализироватьЧисло(Древо::ЗначениеЧисло* узел);
    УказательТип анализироватьСтрока(Древо::ЗначениеСтрока* узел);
    УказательТип анализироватьЛогика(Древо::ЗначениеЛогика* узел);
    УказательТип анализироватьДвойнаяОперация(Древо::ДвойнаяОперация* узел);
    УказательТип анализироватьОднарнаяОперация(Древо::ОднарнаяОперация* узел);
    УказательТип анализироватьВызов(Древо::Вызов* узел);
    УказательТип анализироватьДоступ(Древо::Доступ* узел);
    УказательТип анализироватьИндекс(Древо::Индекс* узел);
    
    // === Проверки типов ===
    
    /// Проверить совместимость типов для присваивания
    bool проверитьПрисваивание(УказательТип цель, УказательТип значение, Позиция позиция);
    
    /// Проверить тип для условия (должен быть Логика или Трит)
    bool проверитьУсловие(УказательТип тип, Позиция позиция);
    
    /// Вывести тип результата бинарной операции
    УказательТип вывестиТипОперации(ТипТокена оператор, УказательТип левый, УказательТип правый);
    
    /// Вывести тип результата унарной операции
    УказательТип вывестиТипУнарной(ТипТокена оператор, УказательТип операнд);
    
    /// Разрешить имя типа в тип
    УказательТип разрешитьТип(const std::string& имя);
    
    // === Регистрация ошибок ===
    
    void ошибка(const std::string& сообщение, Позиция позиция, const std::string& код = "");
    void предупреждение(const std::string& сообщение, Позиция позиция, const std::string& код = "");
    void подсказка(const std::string& сообщение, Позиция позиция, const std::string& код = "");
    
    // === Вспомогательные ===
    
    void зарегистрироватьВстроенные();
};

} // namespace Троица

#endif // T9_TROITSA_SEMANTICS_HPP
